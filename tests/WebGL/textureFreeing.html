<!DOCTYPE html>
<head>
    <title>
        WebGL Texture Freeing Automated Test
    </title>
</head>
<body bgColor="blue"></body>

<script src="../../bagel.js"></script>
<script>

game = Bagel.init({
    id: "game",
    state: "test",
    vars: {
        stage: 0,
        deleteQueue: [],
        deleteOrder: [],
        count: 100,
        deleteTick: 0,
        createTick: 0,
        colorLoops: 10,

        newTexture: i => {
            let canvas = document.createElement("canvas");
            canvas.width = Math.round(Math.random() * 19) + 1;
            canvas.height = Math.round(Math.random() * 19) + 1;

            let ctx = canvas.getContext("2d");
            let value = ((i / game.vars.count) * (150 * game.vars.colorLoops));
            ctx.fillStyle = "rgb(" + [
                (value % 150) + 105,
                Math.floor(value / 150) * game.vars.colorLoops,
                0
            ] + ")";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            return canvas;
        }
    },
    game: {
        sprites: [
            {
                id: "TextureMap",
                left: 0,
                top: 0,
                scripts: {
                    init: [
                        {
                            code: null,
                            stateToRun: "test"
                        }
                    ]
                },
                img: ".Internal.textureMap.0",
                width: 256,
                height: 256
            },
            {
                id: "LineChecker",
                type: "canvas",
                updateRes: false,
                fullRes: false,
                singleTexture: true, // So it doesn't interfere with the texture map
                mode: "animated",
                scripts: {
                    init: [
                        {
                            code: me => {
                                me.width = 256;
                                me.height = 256;
                                me.right = game.width;
                                me.top = 0;

                                me.canvas.width = 256;
                                me.canvas.height = 256;
                            },
                            stateToRun: "test"
                        }
                    ]
                },
                render: (me, game, ctx, canvas) => {
                    let renderer = game.internal.renderer;
                    let gl = renderer.gl;
                    if (me.vars.lastQueue == null) {
                        me.vars.lastQueue = JSON.parse(JSON.stringify(renderer.queue));
                        return;
                    }
                    let lines = renderer.textureMaps[0].lines;

                    let texture = Bagel.internal.render.texture.get(".Internal.textureMap.0", game);

                    if (texture.width != 256) {
                        console.log("Texture map resolution is wrong");
                        debugger;
                        return;
                    }

                    // Check texture bounds for overlaps
                    let logged = false;
                    for (let i in renderer.textures) {
                        if (i.includes(".Internal.textureMap")) continue;

                        let testTexture = renderer.textures[i];
                        let x = testTexture.position.x;
                        let y = testTexture.position.y;
                        let x2 = x + testTexture.width;
                        let y2 = y + testTexture.height;

                        for (let c in renderer.textures) {
                            if (c == i) continue;
                            if (c.includes(".Internal.textureMap")) continue;

                            let testTexture2 = renderer.textures[c];
                            if (testTexture.position.textureID != testTexture2.position.textureID) continue;

                            let otherX = testTexture2.position.x;
                            let otherY = testTexture2.position.y;
                            let otherX2 = otherX + testTexture2.width;
                            let otherY2 = otherY + testTexture2.height;

                            if (
                                x2 > otherX
                                && x < otherX2
                                && y2 > otherY
                                && y < otherY2
                            ) {
                                console.log(`Texture ${i} overlaps with ${c}.`);
                                logged = true;
                            }
                        }
                    }

                    if (logged) {
                        debugger;
                        return;
                    }


                    let glData = new Uint8Array(256 * 256 * 4);
                    gl.readPixels(0, 0, 256, 256, gl.RGBA, gl.UNSIGNED_BYTE, glData); // Slightly hacky but it works

                    let newRow = [];
                    let newLine = [0, 0];
                    let i = 0;
                    while (i < glData.length) {
                        let isBlank = glData.slice(i, i + 4).join("") == "255255255255"; // Background colour
                        let x = (i / 4) % 256;
                        let y = 255 - Math.floor((i / 4) / 256);

                        let cacheIsBlank = false;
                        for (let line of lines[y]) {
                            if (x >= line[0] && x < line[0] + line[1]) {
                                cacheIsBlank = true;
                                break;
                            }
                        }
                        if (isBlank != cacheIsBlank) {
                            console.log("Pixel " + [x, y] + " is incorrect.");
                            console.log("Expected:", isBlank);
                            console.log("Actual:", cacheIsBlank);
                            console.log("Queue:", me.vars.lastQueue);
                            console.log("Cache:", lines[y]);
                            // glData.slice(i - (256 * 4), i)

                            logged = true;
                        }

                        if (isBlank) {
                            newLine[1]++;
                        }
                        else {
                            if (newLine[1] != 0) {
                                newRow.push(newLine);
                            }
                            newLine = [x + 1, 0];

                            glData.set([0, 255, 0, 255], i);
                        }
                        i += 4;
                        if ((i / 4) % 256 == 0) {
                            if (newLine[1] != 0) {
                                newRow.push(newLine);
                            }
                            newLine = [0, 0];
                            if (newRow.toString() != lines[y].toString()) {
                                console.log("============");
                                console.log("Line " + y + " is incorrect.");
                                console.log("Expected:", newRow);
                                console.log("Actual:", lines[y]);
                                console.log("Queue:", me.vars.lastQueue);

                                debugger;
                                return;
                            }
                            newRow = [];
                        }
                    }

                    if (logged) {
                        debugger;
                        return;
                    }

                    ctx.fillStyle = "green";
                    ctx.fillRect(0, 0, 256, 256);
                    for (let y in lines) {
                        for (let line of lines[y]) {
                            ctx.clearRect(line[0], y, line[1], 1);
                        }
                    }

                    me.vars.lastQueue = JSON.parse(JSON.stringify(renderer.queue));
                },
                width: 1,
                height: 1
            }
        ],
        scripts: {
            init: [
                {
                    code: _ => {
                        game.vars.lineCheckSprite = game.get.sprite("LineChecker");
                    },
                    stateToRun: "test"
                }
            ],
            main: [
                {
                    code: _ => {
                        let vars = game.vars;
                        let textureFns = Bagel.internal.render.texture;

                        if (vars.stage == 0) {
                            let texture = vars.newTexture(vars.createTick);

                            id = "Texture" + vars.createTick;
                            textureFns.new(id, texture, game);

                            vars.deleteQueue.push(id);

                            vars.createTick++;
                            if (vars.createTick == vars.count) {
                                let inOrder = new Array(vars.count).fill(0).map((value, index) => index);
                                let newOrder = [];
                                i = 0;
                                while (i < vars.count) {
                                    let index = Math.round(Math.random() * (inOrder.length - 1));

                                    newOrder.push(inOrder[index]);
                                    inOrder.splice(index, 1);
                                    i++;
                                }
                                vars.deleteOrder = newOrder;

                                vars.stage = 1;
                                vars.createTick = 0;
                            }
                        }
                        else {
                            textureFns.delete(vars.deleteQueue[vars.deleteOrder[vars.deleteTick]], game);

                            vars.deleteTick++;
                            if (vars.deleteTick == vars.count) {
                                vars.stage = 0;
                                vars.deleteTick = 0;
                            }
                        }
                    },
                    stateToRun: "test"
                }
            ]
        }
    },
    width: 512, // Slightly weird resolution, so the texture map is displayed properly
    height: 256,
    config: {
        loading: {
            mode: "preload"
        },
        display: {
            renderer: "webgl",
            resolution: "fixed"
        },
        input: {
            mouse: {
                enableContextMenu: true // So you can right click and save it as an image for analysis
            }
        },

        debug: {
            webGLClearDeletedTextures: true
        }
    }
});

</script>
