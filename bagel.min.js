/*
Bagel.js by hedgehog125, see https://github.com/hedgehog125/Bagel.js. License information can be found in license.txt
Button sounds from: https://scratch.mit.edu/projects/42854414/ under CC BY-SA 2.0
WebGL rendererer is heavily based off of https://github.com/quidmonkey/particle_test
*/
Bagel={init:e=>{let t=Bagel.internal.current,n=Bagel.internal.subFunctions.init;Bagel.internal.saveCurrent(),t.game=e;let i=(e=n.check(e)).config.display.renderer,r=Object.keys(Bagel.internal.games).length;if(Bagel.internal.games[e.id]=e,n.misc(e),n.basicRendererInit(e),Bagel.internal.loadPlugin(Bagel.internal.plugin,e,{}),n.listeners(e,e.internal.renderer.canvas,r),n.bundledAssets(e),n.loadingScreen(e),!e.config.disableBagelJSMessage){let t="๐ฅฏ๐ฅฏ",n="";"webgl"==e.config.display.renderer?(t+="๐ฅฏ",n+="WebGL"):(t+="๐",n+="Canvas"),"auto"==i&&(n+=" (via auto mode)"),console.log("| Bagel.js <version> | <hp> | <renderer> |\nhttps://github.com/hedgehog125/Bagel.js".replace("<hp>",t).replace("<renderer>",n).replace("<version>",Bagel.version))}return Bagel.internal.loadCurrent(),e},internal:{plugin:{info:{id:"Internal",description:"The built-in plugin, adds an image based sprite type, a canvas and a text type. Also contains some useful methods."},plugin:{types:{assets:{imgs:{args:{webP:{required:!1,types:["string"],description:"The src of the webP version of the image. Is only used if the browser supports it, otherwise the src is used."},upscale:{required:!1,subcheck:{width:{required:!0,types:["number"],description:"The width you want to upscale the texture to."},height:{required:!0,types:["number"],description:"The height you want to upscale the texture to."},antialias:{required:!0,types:["boolean"],description:"If you want to use antialiasing when upscaling the texture. Don't use for pixel art."},quality:{required:!1,default:"high",check:e=>{if(!["low","medium","high"].includes(e))return'Huh, that\'s not a valid quality option. It has to be either "low", "medium" or "high".'},types:["string"],description:'The image smoothing quality to use if antialiasing is enabled. Either "low", "medium" or "high".'}},types:["object"],description:"How the texture should be upscaled. It won't be by default. Enabling antialiasing may help smooth out low resolution textures on non-antialiased games but it's best to upscale pixel art with it disabled instead if a lot of antialiased textures are being used."}},description:'Images give a sprite (only the sprite type though) its appearance. Just set its "img" argument to the id of the image you want to use.',init:(e,t,n,i,r)=>{let a=new Image;((e,t,n,i)=>{e.onload=(r=>{if(t.upscale){let n=document.createElement("canvas");n.width=t.upscale.width,n.height=t.upscale.height;let i=n.getContext("2d");i.imageSmoothingEnabled=t.upscale.antialias,i.imageSmoothingQuality=t.upscale.quality,t.upscale.antialias?i.drawImage(e,1,1,n.width-2,n.height-2):i.drawImage(e,0,0,n.width,n.height),e=n}Bagel.internal.render.texture.new(t.id,e,n,!1,"static"),i(e)})})(a,e,n,t),e.webP&&Bagel.device.is.webPSupported?a.src=e.webP:a.src=e.src},hrefArgs:["webP"],get:"img"},snds:{args:{ogg:{required:!1,types:["string"],description:"The src of the ogg version of the sound. Is only used if the browser supports it, otherwise the src is used."},duration:{required:!1,types:["number"],description:"The length of the audio file. Specifying it allows the game to load more quickly as the sound will only be requested from the server when it's being played."}},description:"Sounds can be played by anything. They're played using game.playSound(<id>)",init:(e,t,n,i,r)=>{let a=new Audio;null==e.duration?(((e,t)=>{e.onloadedmetadata=(n=>{t(e)})})(a,t),a.preload="metadata"):(a.preload="none",(e=>{Object.defineProperty(a,"duration",{get:t=>e})})(e.duration),t(a)),e.ogg&&Bagel.device.is.oggSupported?a.src=e.ogg:a.src=e.src},hrefArgs:["ogg"],get:"snd",forcePreload:!0},spritesheets:{args:{frames:{required:!0,check:e=>{if("number"!=typeof e)return"Oops, this should be a number and you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."},checkEach:!0,types:["array"],description:"How many frames there are for each animation. Animation frames go along the x axis."},animations:{required:!0,check:e=>{if("string"!=typeof e)return"Oops, this should be a string and you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."},checkEach:!0,types:["array"],description:"The names of the different animations. Separate animations go down the y axis."}},init:(e,t,n,i,r)=>{let a=new Image;((e,n,i)=>{e.onload=(r=>{let a=0;for(let e in n.frames)n.frames[e]>a&&(a=n.frames[e]);let s=!1;e.width%a!=0&&(console.warn("The image width isn't divisible by the \"frames\" argument. You should probably check if both of them're correct."),s=!0),e.height%n.animations.length&&(console.warn("The image height isn't divisible by the length of the \"animations\" argument. You should probably check if both of them're correct."),s=!0),s&&console.log("For the image asset "+JSON.stringify(n.id)+".");let o=e.width/a,l=e.height/n.animations.length,d=(i.internal.assets.assets,0);for(;d<n.animations.length;){let t=n.animations[d],r=0;for(;r<n.frames[d];){let a=n.id+"."+t+"."+r,s=document.createElement("canvas");s.width=o,s.height=l,s.getContext("2d").drawImage(e,-r*o,-d*l);let u=Bagel.internal.render.texture;u.get(a,i)?(console.error("Hmm, Bagel.js ran into a problem with the spritesheet "+JSON.stringify(n.id)+". The image id "+JSON.stringify(a)+" has already been taken. Double check the ids of your assets."),Bagel.internal.oops(i)):u.new(a,s,i,!1,"static"),r++}d++}t(n)})})(a,e,n),a.src=e.src},description:"Contains many separate images. Useful for animations.",get:"spritesheet"},fonts:{args:{},init:(e,t)=>{fetch(e.src).then(e=>e.json().then(e=>{t(e)}))},set:(e,t,n,i,r)=>{if("object"!=Bagel.internal.getTypeOf(e))return"Oh no! This can only be an object but you tried to use "+Bagel.internal.an(Bagel.internal.getTypeOf(value))+". Make sure that it's actually a Bagel.js font.";let a=e.widths.length;r.vars.font.characterSets[a]||(console.error("Huh, the font "+JSON.stringify(t.id)+" doesn't have a matching character set. It's got "+a+"."),console.log("These are the character sets:"),console.log(r.vars.font.characterSets),Bagel.internal.oops(i));let s=0,o=0,l=[],d=0;for(let t in e.widths)l.push(d),s+=e.widths[t],o+=e.heights[t],d+=e.widths[t]*e.heights[t];e.starts=l,e.avgWidth=Math.ceil(s/e.widths.length),e.avgHeight=Math.ceil(o/e.widths.length),e.maxHeight=Math.max(...e.heights),n(e)},description:'For use with "text" sprites, generate fonts using Bagel.font.generate.',get:"font"}},sprites:{sprite:{args:{x:{required:!1,default:"centered",types:["number","string","function"],description:'The x position for the sprite. Can also be set to "centered" to centre it along the x axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.width - 50"'},y:{required:!1,default:"centered",types:["number","string","function"],description:'The y position for the sprite. Can also be set to "centered" to centre it along the y axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.height - 50"'},left:{required:!1,types:["number"],description:"Where you want the left side of the sprite to be positioned along the x axis."},right:{required:!1,types:["number"],description:"Where you want the right side of the sprite to be positioned along the x axis."},top:{required:!1,types:["number"],description:"Where you want the top of the sprite to be positioned along the y axis."},bottom:{required:!1,types:["number"],description:"Where you want the bottom of the sprite to be positioned along the y axis."},img:{required:!1,default:null,types:["string","undefined"],description:"The image for the sprite to use to start with. If set to null or not specified, the sprite will be invisible."},width:{required:!1,types:["number","string"],description:'The width for the sprite. Defaults to the width of the image. You can also set it to a multiple of the image width by setting it to "1x", "2x", etc.'},height:{required:!1,types:["number","string"],description:'The height for the sprite. Defaults to the height of the image. You can also set it to a multiple of the image height by setting it to "1x", "2x", etc.'},scale:{required:!1,default:1,types:["number"],description:"The scale of the sprite. If both the width and height are unspecified, the sprite width and height are set to the image width and height multiplied by the scale."},alpha:{required:!1,default:1,types:["number"],description:"The alpha of the sprite. 1 is fully visible, 0.5 is partially and 0's invisible."},angle:{required:!1,default:90,types:["number"],description:"The angle of the sprite. In degrees. 0ยบ = up. 180ยบ = down. -90ยบ = left. 90ยบ = right (not rotated)."},crop:{required:!1,default:{},subcheck:{x:{required:!1,default:null,types:["number"],description:"The x coordinate to start using the image data. Anything before it won't be used."},y:{required:!1,default:null,types:["number"],description:"The y coordinate to start using the image data. Anything before it won't be used."},width:{required:!1,default:null,types:["number"],description:"The number of horizontal pixels to use from the image. (from the x coordinate). Anything after isn't used."},height:{required:!1,default:null,types:["number"],description:"The number of vertical pixels to use from the image. (from the y coordinate). Anything after isn't used."}},types:["object"],description:"How the sprite should be cropped."},tint:{required:!1,types:["string"],description:"The HTML colour to tint the sprite with. Defaults to none (#00000000). The alpha is the amount."}},cloneArgs:{x:{syntax:{description:'The x position for the clone. Can also be set to "centered" to centre it along the x axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.width - 50"'},mode:"replace"},y:{syntax:{description:'The y position for the clone. Can also be set to "centered" to centre it along the y axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.height - 50"'},mode:"replace"},left:{mode:"replace"},right:{mode:"replace"},top:{mode:"replace"},bottom:{mode:"replace"},img:{syntax:{description:"The image for the clone to use to start with. If set to null or not specified anywhere, the clone will be invisible."},mode:"replace"},width:{syntax:{description:'The width for the clone. Defaults to the width of the image. You can also set it to a multiple of the image width by setting it to "1x", "2x", etc.'},mode:"replace"},height:{syntax:{description:'The height for the clone. Defaults to the height of the image. You can also set it to a multiple of the image height by setting it to "1x", "2x", etc.'},mode:"replace"},scale:{syntax:{description:"The scale of the clone. If both the width and height are unspecified, the sprite width and height are set to the image width and height multiplied by the scale."},mode:"replace"},alpha:{syntax:{description:"The alpha of the clone. 1 is fully visible, 0.5 is partially and 0's invisible."},mode:"replace"},angle:{syntax:{description:"The angle of the clone. In degrees. 0ยบ = up. 180ยบ = down. -90ยบ = left. 90ยบ = right."},mode:"replace"},crop:{mode:"replace"},tint:{mode:"replace"}},listeners:{fns:{xy:(e,t,n,i,r,a,s,o)=>{if("number"==typeof t)return isNaN(t)?"Huh, looks like you've done something wrong in a calculation somewhere in your program. Sprite "+JSON.stringify(a.id)+"'s "+n+" is NaN. This is usually caused by having a non number somewhere in a calcuation.":(r.vars.sprite.updateAnchors(a,"x"==n,"y"==n),void(a.internal.renderUpdate=!0));if("string"==typeof t&&"centered"==t){if(o&&("x"==n&&(e.hasOwnProperty("left")||e.hasOwnProperty("right"))||"y"==n&&(e.hasOwnProperty("top")||e.hasOwnProperty("bottom"))))return;return e[n]=i["x"==n?"width":"height"]/2,r.vars.sprite.updateAnchors(a,"x"==n,"y"==n),void(a.internal.renderUpdate=!0)}return"function"==typeof t?!i.loaded||o?".rerun":(e[n]=t(a,i),r.vars.sprite.updateAnchors(a,"x"==n,"y"==n),void(a.internal.renderUpdate=!0)):'Oops, this can only be a function, a number or the string "centered". In the sprite '+JSON.stringify(a.id)+"."+n+". You tried to set it to "+JSON.stringify(t)+"."},dimensions:(e,t,n,i,r,a,s,o)=>{if(!i.loaded)return".rerun";if("number"==typeof t){if(isNaN(t))return"Huh, looks like you've done something wrong in a calculation somewhere in your program. Sprite "+JSON.stringify(a.id)+"'s "+n+" is NaN. This is usually caused by having a non number somewhere in a calcuation.";{let t;if(e.img){if((t=Bagel.get.asset.img(e.img,a.game,!0))||(t=Bagel.internal.render.texture.get(e.img,a.game)),!t)return"Huh, Bagel.js couldn't find an image asset or texture with the id "+JSON.stringify(e.img)+". Make sure you added it in Game.game.assets.imgs or if you're making or using a plugin, that the texture is created before it's accessed.";{if("boolean"==typeof t)return".rerun";let n=Math.abs(e.width)/t.width,i=Math.abs(e.height)/t.height;e.scale=(n+i)/2}}return o||(r.vars.sprite.updateAnchors(a,"width"==n,"height"==n),r.vars.sprite.resetCrop(a,t||{width:1,height:1})),void(a.internal.renderUpdate=!0)}}if("string"==typeof t&&t.includes("x")){let i=parseFloat(t.split("x")[0]);if(null==e.img)return e[n]=1,void(o||(r.vars.sprite.updateAnchors(a,"width"==n,"height"==n),r.vars.sprite.resetCrop(a,{width:1,height:1})));let s=Bagel.get.asset.img(e.img,a.game,!0);if(s||(s=Bagel.internal.render.texture.get(e.img,a.game)),!s)return":/ Bagel.js couldn't find an image asset or texture with the id "+JSON.stringify(e.img)+". Make sure you added it in Game.game.assets.imgs or if you're making or using a plugin, that the texture is created before it's accessed.";if("boolean"==typeof s)return".rerun";if(e[n]=s[n]*i,e.width&&e.height){let t=e.width/s.width,n=e.height/s.height;e.scale=(t+n)/2}return o||(r.vars.sprite.updateAnchors(a,"width"==n,"height"==n),r.vars.sprite.resetCrop(a,s)),void(a.internal.renderUpdate=!0)}if("function"==typeof t){let s;if(e[n]=t(a,i),e.img){if((s=Bagel.get.asset.img(e.img,a.game,!0))||(s=Bagel.internal.render.texture.get(e.img,a.game)),!s)return"Hmm, Bagel.js couldn't find an image asset or texture with the id "+JSON.stringify(e.img)+". Make sure you added it in Game.game.assets.imgs or if you're making or using a plugin, that the texture is created before it's accessed.";if("boolean"==typeof s)return".rerun";let t=e.width/s.width,n=e.height/s.height;e.scale=(t+n)/2}return o||(r.vars.sprite.updateAnchors(a,"width"==n,"height"==n),r.vars.sprite.resetCrop(a,s||{width:1,height:1})),void(a.internal.renderUpdate=!0)}if(null==t&&e.scale){if(null==e.img)return e[n]=1,void(o||(r.vars.sprite.updateAnchors(a,"width"==n,"height"==n),r.vars.sprite.resetCrop(a,{width:1,height:1})));let t=Bagel.get.asset.img(e.img,a.game,!0);return t||(t=Bagel.internal.render.texture.get(e.img,a.game)),t?"boolean"==typeof t?".rerun":(e[n]=t[n]*e.scale,o||(r.vars.sprite.updateAnchors(a,"width"==n,"height"==n),r.vars.sprite.resetCrop(a,t)),void(a.internal.renderUpdate=!0)):"Oh no! Bagel.js couldn't find an image asset or texture with the id "+JSON.stringify(e.img)+". Make sure you added it in Game.game.assets.imgs or if you're making or using a plugin, that the texture is created before it's accessed."}return"Hmm. This can only be a function, a multiple of its image "+n+" (e.g 1x, 2x, 0.3x etc.) or a number. In the sprite "+JSON.stringify(a.id)+"."+n+". You tried to set it to "+JSON.stringify(t)+".\nIf you tried to set the other width/height attribute, you'll need to define this one as well."}},property:{x:{set:"xy"},y:{set:"xy"},img:{set:(e,t,n,i,r,a,s,o)=>{if(a.internal.imgWaiting=!0,t){let n=Bagel.get.asset.img(t,i,!0);if("boolean"==typeof n){if(n)return".rerun";if(!(n=Bagel.internal.render.texture.get(t,i)))return i.loaded?"Oh no! Bagel.js couldn't find an image asset or a texture with the id "+JSON.stringify(t)+". Make sure you added it in Game.game.assets.imgs or if you're making or using a plugin, that the texture is created before it's accessed.":".rerun"}if(!o){let t=e.scale;a.width=n.width*t,a.height=n.height*t}a.internal.imgWaiting=!1}a.internal.renderUpdate=!0}},width:{set:"dimensions"},height:{set:"dimensions"},left:{set:(e,t,n,i,r,a,s,o)=>{if(o){if("centered"!=e.x)return;if(null==e.width)return a.x=t,".rerun"}a.x=t+e.width/2}},right:{set:(e,t,n,i,r,a,s,o)=>{if(o){if("centered"!=e.x)return;if(null==e.width)return a.x=t,".rerun"}a.x=t-e.width/2}},top:{set:(e,t,n,i,r,a,s,o)=>{if(o){if("centered"!=e.y)return;if(null==e.height)return a.y=t,".rerun"}a.y=t+e.height/2}},bottom:{set:(e,t,n,i,r,a,s,o)=>{if(o){if("centered"!=e.y)return;if(null==e.height)return a.y=t,".rerun"}a.y=t-e.height/2}},scale:{set:(e,t,n,i,r,a,s,o)=>{if(!o||null==e.width&&null==e.height){if(!i.loaded)return".rerun";if("number"!=typeof t)return"Erm, this can only be a number. In the sprite "+JSON.stringify(a.id)+".scale. You tried to set it to "+JSON.stringify(t)+".";if(e.img){let n=Bagel.get.asset.img(e.img,i,!0);if(n||(n=Bagel.internal.render.texture.get(e.img,i)),!n)return"Hmm, Bagel.js couldn't find an image asset or texture with the id "+JSON.stringify(e.img)+" (Sprite.img must be set in order to change the sprite scale). Make sure you added it in Game.game.assets.imgs or if you're making or using a plugin, that the texture is created before it's accessed.";if("boolean"==typeof n)return".rerun";e.width=n.width*t,e.height=n.height*t}else e.width=1,e.height=1;o||(a.internal.renderUpdate=!0)}}},alpha:{set:(e,t,n,i,r,a)=>{t>1?e.alpha=1:t<0&&(e.alpha=0),a.internal.renderUpdate=!0}},angle:{set:(e,t,n,i,r,a)=>{let s=a.internal.cache,o=Bagel.maths.degToRad(e.angle);s.sin=Math.sin(o),s.cos=Math.cos(o),e.angle=Bagel.maths.capAngle(e.angle),a.internal.renderUpdate=!0}},crop:{set:(e,t,n,i,r,a,s,o,l,d)=>{let u,g;if(a.img&&((g=Bagel.get.asset.img(a.img,s.game,!0))||(g=Bagel.internal.render.texture.get(a.img,s.game))),l&&null==t){if("x"==n||"y"==n)e[n]=0;else{if(!i.loaded)return".rerun";if(g){if("boolean"==typeof g)return".rerun";e[n]=g[n]-e["width"==n?"x":"y"]}else e[n]=1}u=!0}if(!u&&"number"==typeof t){if(isNaN(t))return"Huh, something must have gone wrong in a calculation. You tried to set this to NaN.";if(t<0)return"Hmm, this has to be at least 0.";s.internal.renderUpdate=!0,u=!0}return u?(g||(g={width:1,height:1}),"x"!=n&&"y"!=n||null==d||(e["x"==n?"width":"height"]+=d-t),e.width+e.x>g.width&&(e.width=g.width-e.x),e.height+e.y>g.height&&(e.height=g.height-e.y),void(s.internal.crop=!(0==e.x&&0==e.y&&e.width==g.width&&e.height==e.height))):"Oh no! This has to be a number and you tried to use "+Bagel.internal.an(Bagel.internal.getTypeOf(t))+"."},subListen:!0},tint:{set:(e,t,n,i,r,a)=>{a.internal.renderUpdate=!0,a.internal.tint=!(null==t||"#00000000"==t||"rbga(0, 0, 0, 0)"==t)}}},trigger:!0},description:"A basic type of sprite. Has the appearance of the image specified.",check:(e,t,n,i,r)=>{},init:(e,t,n)=>{e.last={collision:null},e.internal.cache={},e.internal.imgWaiting=!0;let i=e.internal.Bagel.properties,r=(null!=i.width)+(null!=i.height);if(1==r)console.error('Oh no! You only specified one of the dimensions for this sprite. You need to specifiy both unless you set the "scale" attribute instead.'),Bagel.internal.oops(t);else if(2==r){let e=t.get.asset.img(i.img,!0)||Bagel.internal.render.texture.get(i.img,t);"object"==typeof e&&(i.scale=(i.width/e.width+i.height/e.width)/2)}},render:{onVisible:(e,t)=>{e.internal.renderUpdate=!1;let n=e.internal;if(!n.imgWaiting){let i=e.internal.Bagel.properties;return t({x:i.x,y:i.y,width:i.width,height:i.height,image:i.img,rotation:i.angle,alpha:i.alpha,crop:n.crop?i.crop:null,tint:n.tint?i.tint:null},e.game,!1)}},onInvisible:(e,t)=>t(e.internal.Bagel.renderID,e.game),whileVisible:(e,t,n,i)=>{let r=e.internal;if(r.renderUpdate){if(r.renderUpdate=!1,r.imgWaiting)return i(r.Bagel.renderID,e.game);{let n=r.Bagel.properties;return t(r.Bagel.renderID,{x:n.x,y:n.y,width:n.width,height:n.height,image:n.img,rotation:n.angle,alpha:n.alpha,crop:r.crop?n.crop:null,tint:r.tint?n.tint:null},e.game,!1)}}}}},canvas:{args:{x:{required:!1,default:"centered",types:["number","string","function"],description:'The x position for the canvas. Can also be set to "centered" to centre it along the x axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.width - 50"'},y:{required:!1,default:"centered",types:["number","string","function"],description:'The y position for the canvas. Can also be set to "centered" to centre it along the y axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.height - 50"'},left:{required:!1,types:["number"],description:"Where you want the left side of the canvas sprite to be positioned along the x axis."},right:{required:!1,types:["number"],description:"Where you want the right side of the canvas sprite to be positioned along the x axis."},top:{required:!1,types:["number"],description:"Where you want the top of the canvas sprite to be positioned along the y axis."},bottom:{required:!1,types:["number"],description:"Where you want the bottom of the canvas sprite to be positioned along the y axis."},width:{required:!0,types:["number","function"],description:'The width for the canvas. Can also be a function that returns a position when the game loads. e.g:\n"(me, game) => game.width * 0.2"'},height:{required:!0,types:["number","function"],description:'The height for the canvas. Can also be a function that returns a position when the game loads. e.g:\n"(me, game) => game.height * 0.2"'},angle:{required:!1,default:90,types:["number"],description:"The angle of the canvas. In degrees. 0ยบ = up. 180ยบ = down. -90ยบ = left. 90ยบ = right (not rotated)."},alpha:{required:!1,default:1,types:["number"],description:"The alpha of the canvas. 1 is fully visible, 0.5 is partially and 0's invisible."},fullRes:{required:!1,default:!1,types:["boolean"],description:"If true, the canvas width and height will be automatically changed to ensure it's rendered at the full resolution."},updateRes:{required:!1,default:!0,types:["boolean"],description:"If the canvas width and height should be changed after the sprite is made. Disabling this is useful for prerendering things onto this canvas as the canvas is cleared when the resolution is changed. Overwrites fullRes except when the canvas is first created."},render:{required:!1,types:["function"],description:'Renders each frame for the canvas. The arguments provided are: "sprite", "game", "ctx", "canvas", "scaleX" and "scaleY".'},prerender:{required:!1,types:["function"],description:'Prerenders the canvas. Called when the canvas sprite is first made and when the resolution is updated. The arguments provided are: "sprite", "game", "ctx", "canvas", "scaleX" and "scaleY".'},mode:{required:!1,default:"auto",check:e=>{if(!["auto","static","animated"].includes(e))return'Huh, that\'s not a valid value. It has to be "auto", "static" or "animated". You tried to use '+JSON.stringify(e)+"."},types:["string"],description:'Tells Bagel.js how to optimise for this canvas. It\'s not important in the canvas renderer but in the WebGL renderer, the value determines how the texture is handled internally.\n"auto" will detect when you render to the canvas and update the texture after. This adds a slight overhead.\n"static" will assume the canvas won\'t be updated frequently but you can still update it by returning true from the function you set for your "render" argument.\nLastly "animated" will assume the canvas will be updated every frame, you can return true if you haven\'t though.\n\nFor all of these modes, Bagel.js can optimise differently depending on how you use it on a second by second basis. A the texture of even a static canvas can become a more memory intensive but faster to update single texture if it\'s updated on 3 consecutive frames (auto and animated become a single texture after 1). If any canvas isn\'t updated at all for a whole second, it\'ll become part of a combined texture to reduce memory usage. "auto" will also use a single texture if less than 80% of the total textures supported by the GPU are being used. Both "auto" and "static" canvases will be moved to a combined texture once updated if 90% of textures are being used or will be moved before an update if 100% of textures are full and a new WebGL texture is required.\nIn most circumstances, the "mode" argument only specifies the start point and in the case of "auto", how the renders will be detected.'}},cloneArgs:{x:{syntax:{description:'The x position for the clone. Can also be set to "centered" to centre it along the x axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.width - 50"'},mode:"replace"},y:{syntax:{description:'The y position for the clone. Can also be set to "centered" to centre it along the x axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.height - 50"'},mode:"replace"},left:{mode:"replace"},right:{mode:"replace"},top:{mode:"replace"},bottom:{mode:"replace"},width:{syntax:{description:'The width for the clone. Can also be a function that returns a position when the game loads. e.g:\n"(me, game) => game.width * 0.2"'},mode:"replace"},height:{syntax:{description:'The height for the clone. Can also be a function that returns a position when the game loads. e.g:\n"(me, game) => game.height * 0.2"'},mode:"replace"},angle:{syntax:{description:"The angle of the clone. In degrees. 0ยบ = up. 180ยบ = down. -90ยบ = left. 90ยบ = right (not rotated)."},mode:"replace"},alpha:{syntax:{description:"The alpha of the clone. 1 is fully visible, 0.5 is partially and 0's invisible."},mode:"replace"},fullRes:{mode:"replace"},updateRes:{mode:"replace"},render:{syntax:{description:'Renders each frame for the clone. The arguments provided are: "sprite", "game", "ctx" and "canvas".'},mode:"replace"},prerender:{syntax:{description:'Prerenders the canvas. Called when the clone is first made and when the resolution is updated. The arguments provided are: "sprite", "game", "ctx", "canvas", "scaleX" and "scaleY".'},mode:"replace"},mode:{mode:"replace"}},listeners:{fns:{xy:(e,t,n,i,r,a,s,o)=>{if("number"==typeof t)return isNaN(t)?"Huh, looks like you've done something wrong in a calculation somewhere in your program. Sprite "+JSON.stringify(a.id)+"'s "+n+" is NaN. This is usually caused by having a non number somewhere in a calcuation.":(r.vars.sprite.updateAnchors(a,"x"==n,"x"!=n),void(a.internal.renderUpdate=!0));if("string"==typeof t&&"centered"==t){if(o&&("x"==n&&(e.hasOwnProperty("left")||e.hasOwnProperty("right"))||"y"==n&&(e.hasOwnProperty("top")||e.hasOwnProperty("bottom"))))return;return e[n]=i["x"==n?"width":"height"]/2,r.vars.sprite.updateAnchors(a,"x"==n,"x"!=n),void(a.internal.renderUpdate=!0)}return!i.loaded||o?".rerun":"function"==typeof t?(e[n]=t(a,i),r.vars.sprite.updateAnchors(a,"x"==n,"x"!=n),void(a.internal.renderUpdate=!0)):(console.error('Oops, this can only be a function, a number or the string "centered". In the sprite '+JSON.stringify(a.id)+"."+n+". You tried to set it to "+JSON.stringify(t)+"."),void Bagel.internal.oops(i))},dimensions:(e,t,n,i,r,a,s,o)=>{let l=!1;if("number"==typeof t&&(r.vars.sprite.updateAnchors(a,"width"==n,"width"!=n),a.internal.renderUpdate=!0,l=!0),"function"==typeof t){if(!i.loaded||o)return".rerun";e[n]=t(a,i),r.vars.sprite.updateAnchors(a,"width"==n,"width"!=n),a.internal.renderUpdate=!0,l=!0}if(a.updateRes){let t,n,i=a.game.internal.renderer.scaleX,r=a.game.internal.renderer.scaleY;a.fullRes?(t=e.width*i*window.devicePixelRatio,n=e.height*r*window.devicePixelRatio):(t=e.width,n=e.height);let s=a.internal.last;s.width==t&&s.height==n||(a.canvas.width=t,a.canvas.height=n,s.width=t,s.height=n,a.scaleX=a.canvas.width/e.width,a.scaleY=a.canvas.height/e.height)}l||(console.error("Oops, this can only be a function or a number. In the sprite "+JSON.stringify(a.id)+"."+n+". You tried to set it to "+JSON.stringify(t)+"."),Bagel.internal.oops(i))}},property:{x:{set:"xy"},y:{set:"xy"},left:{set:(e,t,n,i,r,a,s,o)=>{o&&"centered"!=e.x||(a.x=t+e.width/2)}},right:{set:(e,t,n,i,r,a,s,o)=>{o&&"centered"!=e.x||(a.x=t-e.width/2)}},top:{set:(e,t,n,i,r,a,s,o)=>{o&&"centered"!=e.y||(a.y=t+e.height/2)}},bottom:{set:(e,t,n,i,r,a,s,o)=>{o&&"centered"!=e.y||(a.y=t-e.height/2)}},width:{set:"dimensions"},height:{set:"dimensions"},alpha:{set:(e,t,n,i,r,a)=>{t>1?e.alpha=1:t<0&&(e.alpha=0),a.internal.renderUpdate=!0}},angle:{set:(e,t,n,i,r,a)=>{let s=a.internal.cache,o=Bagel.maths.degToRad(e.angle);s.sin=Math.sin(o),s.cos=Math.cos(o),e.angle=Bagel.maths.capAngle(e.angle),a.internal.renderUpdate=!0}}},events:{delete:e=>{e.internal.canvasID&&Bagel.internal.render.texture.delete(e.internal.canvasID,e.game)}},trigger:!0},description:'A "2d" canvas sprite. Anything rendered onto the canvas gets rendered onto the main canvas. (but will usually be scaled down depending on the width and height of the canvas)',init:(e,t,n)=>{let i=document.createElement("canvas"),r=i.getContext("2d");"auto"==e.mode&&((e,t,n)=>{let i={clearRect:(...t)=>{e.internal.canvasUpdated=!0,n.internalclearRect(...t)},drawFocusIfNeeded:(...t)=>{e.internal.canvasUpdated=!0,n.internaldrawFocusIfNeeded(...t)},drawImage:(...t)=>{e.internal.canvasUpdated=!0,n.internaldrawImage(...t)},fill:(...t)=>{e.internal.canvasUpdated=!0,n.internalfill(...t)},fillRect:(...t)=>{e.internal.canvasUpdated=!0,n.internalfillRect(...t)},fillText:(...t)=>{e.internal.canvasUpdated=!0,n.internalfillText(...t)},putImageData:(...t)=>{e.internal.canvasUpdated=!0,n.internalputImageData(...t)},rect:(...t)=>{e.internal.canvasUpdated=!0,n.internalrect(...t)},stroke:(...t)=>{e.internal.canvasUpdated=!0,n.internalstroke(...t)},strokeRect:(...t)=>{e.internal.canvasUpdated=!0,n.internalstrokeRect(...t)},strokeText:(...t)=>{e.internal.canvasUpdated=!0,n.internalstrokeText(...t)}};for(let e in i)n["internal"+e]=n[e],n[e]=i[e]})(e,0,r),e.canvas=i,i.width=e.width,i.height=e.height,e.fullRes&&(i.width*=t.internal.renderer.scaleX,i.height*=t.internal.renderer.scaleY),e.ctx=r;let a=e.internal;a.canvasID=".Internal.canvas."+e.id,a.canvasUpdated=!1,a.last={},a.prerendered=!1,a.cache={},e.last={collision:null},e.internal.prerenderBase=e.prerender,(e=>{Object.defineProperty(e,"prerender",{set:t=>{e.internal.prerenderBase=t,"function"==typeof t&&(e.internal.prerender=(t=>{Bagel.internal.saveCurrent();let n=Bagel.internal.current;n.game=e.game,n.plugin=null,n.sprite=e,e.internal.prerenderBase(e,e.game,e.ctx,e.canvas,e.scaleX,e.scaleY),e.updated=!0,e.internal.prerendered=!0,Bagel.internal.loadCurrent()}))},get:t=>e.internal.prerender})})(e),e.prerender=e.internal.prerenderBase,e.scaleX=e.canvas.width/e.width,e.scaleY=e.canvas.height/e.height,e.updated=!1,n.vars.sprite.updateAnchors(e,!0,!0)},render:{init:(e,t)=>{let n,i,r=e.canvas;e.fullRes?(n=e.width*e.game.internal.renderer.scaleX,i=e.height*e.game.internal.renderer.scaleY):(n=e.width,i=e.height),n=Math.max(Math.round(n),1),i=Math.max(Math.round(i),1),r.width=n,r.height=i,e.internal.last.width=n,e.internal.last.height=i,e.scaleX=r.width/e.width,e.scaleY=r.height/e.height,Bagel.internal.render.texture.new(e.internal.canvasID,r,e.game,!1,e.mode),e.internal.renderUpdate=!1},onVisible:(e,t)=>{let n=e.internal;return n.renderUpdate=!1,n.prerendered||n.prerenderBase&&e.prerender(),t({x:e.x,y:e.y,width:e.width,height:e.height,image:n.canvasID,rotation:e.angle,alpha:e.alpha},e.game,!1)},onInvisible:(e,t)=>t(e.internal.Bagel.renderID,e.game),whileVisible:(e,t,n,i,r,a)=>{let s,o=e.internal;if(e.updateRes){let t,n;e.fullRes?(t=e.width*e.game.internal.renderer.scaleX,n=e.height*e.game.internal.renderer.scaleY):(t=e.width,n=e.height),t=Math.max(t,1),n=Math.max(n,1);let i=o.last;i.width==t&&i.height==n||(e.canvas.width=t,e.canvas.height=n,i.width=t,i.height=n,e.scaleX=e.canvas.width/e.width,e.scaleY=e.canvas.height/e.height,o.prerenderBase&&e.prerender())}if(o.prerendered||o.prerenderBase&&e.prerender(),e.render){let t=Bagel.internal.current;Bagel.internal.saveCurrent(),t.plugin=null,t.sprite=e,s=e.render(e,e.game,e.ctx,e.canvas,e.scaleX,e.scaleY),Bagel.internal.loadCurrent()}(e.updated||e.internal.canvasUpdated||"animated"==e.mode&&!0!==s||"animated"!=e.mode&&!0===s)&&(Bagel.internal.render.texture.update(e.internal.canvasID,e.canvas,e.game),e.internal.canvasUpdated=!1,e.updated=!1,a.vars.sprite.updateAnchors(e,!0,!0)),e.internal.renderUpdate&&(e.internal.renderUpdate=!1,t(e.internal.Bagel.renderID,{x:e.x,y:e.y,width:e.width,height:e.height,image:e.internal.canvasID,rotation:e.angle,alpha:e.alpha},e.game,!1))}}},text:{args:{x:{required:!1,default:"centered",types:["number","string","function"],description:'The x position for the text. Can also be set to "centered" to centre it along the x axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.width - 50"'},y:{required:!1,default:"centered",types:["number","string","function"],description:'The y position for the text. Can also be set to "centered" to centre it along the y axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.height - 50"'},left:{required:!1,types:["number"],description:"Where you want the left side of the text to be positioned along the x axis."},right:{required:!1,types:["number"],description:"Where you want the right side of the text to be positioned along the x axis."},top:{required:!1,types:["number"],description:"Where you want the top of the text to be positioned along the y axis."},bottom:{required:!1,types:["number"],description:"Where you want the bottom of the text to be positioned along the y axis."},alpha:{required:!1,default:1,types:["number"],description:"The alpha of the text. 1 is fully visible, 0.5 is partially and 0's invisible."},text:{required:!0,types:["string"],description:"The text that this sprite should display."},font:{required:!1,check:(e,t)=>{void 0===e&&(t.bitmap?t.font=".Internal.defaultFont":t.font="Arial")},types:["string"],description:'The name of the font to use. An HTML font if "bitmap" is false or a font asset if it\'s true.'},wordWrapWidth:{required:!1,types:["number"],description:"The maximum width of a line before it wraps. Defaults to no wrapping."},size:{required:!1,default:20,types:["number"],description:"The font size in game pixels."},bitmap:{required:!1,default:!1,types:["boolean"],description:"If HTML (false) or bitmap (true) fonts should be used."},color:{required:!1,default:"black",types:["string"],description:'The colour for the text. An HTML colour. (e.g "red", "rgb(1, 2, 3)" etc.)'}},cloneArgs:{x:{syntax:{description:'The x position for the clone. Can also be set to "centered" to centre it along the x axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.width - 50"'},mode:"replace"},y:{syntax:{description:'The y position for the clone. Can also be set to "centered" to centre it along the y axis, or set to a function that returns a position when the game loads. e.g:\n"(me, game) => game.height - 50"'},mode:"replace"},left:{mode:"replace"},right:{mode:"replace"},top:{mode:"replace"},bottom:{mode:"replace"},alpha:{syntax:{description:"The alpha of the clone. 1 is fully visible, 0.5 is partially and 0's invisible."},mode:"replace"},text:{syntax:{description:"The text that this clone should display."},mode:"replace"},font:{mode:"replace"},wordWrapWidth:{mode:"replace"},size:{mode:"replace"},bitmap:{mode:"replace"},color:{mode:"replace"}},listeners:{fns:{xy:(e,t,n,i,r,a,s,o)=>{if("number"==typeof t)return isNaN(t)?"Huh, looks like you've done something wrong in a calculation somewhere in your program. Sprite "+JSON.stringify(a.id)+"'s "+n+" is NaN. This is usually caused by having a non number somewhere in a calcuation.":(r.vars.sprite.updateAnchors(a,"x"==n,"y"==n),void(a.internal.renderUpdate=!0));if("string"==typeof t&&"centered"==t){if(o&&("x"==n&&(e.hasOwnProperty("left")||e.hasOwnProperty("right"))||"y"==n&&(e.hasOwnProperty("top")||e.hasOwnProperty("bottom"))))return;return e[n]=i["x"==n?"width":"height"]/2,r.vars.sprite.updateAnchors(a,"x"==n,"y"==n),void(a.internal.renderUpdate=!0)}return!i.loaded||o?".rerun":"function"==typeof t?(e[n]=t(a,i),r.vars.sprite.updateAnchors(a,"x"==n,"y"==n),void(a.internal.renderUpdate=!0)):(console.error('Oops, this can only be a function, a number or the string "centered". In the sprite '+JSON.stringify(a.id)+"."+n+". You tried to set it to "+JSON.stringify(t)+"."),void Bagel.internal.oops(i))},rerender:(e,t,n,i,r,a,s,o)=>{o||(a.internal.needsRerender=!0,r.vars.font.prerender(a,r,!0),r.vars.sprite.updateAnchors(a,!0,!0))}},property:{x:{set:"xy"},y:{set:"xy"},left:{set:(e,t,n,i,r,a,s,o)=>{o&&"centered"!=e.x||(a.x=t+a.width/2)}},right:{set:(e,t,n,i,r,a,s,o)=>{o&&"centered"!=e.x||(a.x=t-a.width/2)}},top:{set:(e,t,n,i,r,a,s,o)=>{o&&"centered"!=e.y||(a.y=t+a.height/2)}},bottom:{set:(e,t,n,i,r,a,s,o)=>{o&&"centered"!=e.y||(a.y=t-a.height/2)}},alpha:{set:(e,t,n,i,r,a,s)=>{t>1?e.alpha=1:t<0&&(e.alpha=0),a.internal.renderUpdate=!0}},text:{set:"rerender"},font:{set:(e,t,n,i,r,a,s,o)=>{if(e.bitmap&&!i.get.asset.font(t,!0))return"Huh, the font "+JSON.stringify(t)+" doesn't seem to exist.";o||(a.internal.needsRerender=!0,r.vars.font.prerender(a,r,!0),r.vars.sprite.updateAnchors(a,!0,!0))}},wordWrapWidth:{set:"rerender"},size:{set:"rerender"},bitmap:{set:(e,t,n,i,r,a,s,o)=>{o||(e.font=t?".Internal.defaultFont":"Arial",a.internal.needsRerender=!0,r.vars.font.prerender(a,r,!0),r.vars.sprite.updateAnchors(a,!0,!0))}},color:{set:"rerender"}},events:{delete:e=>{Bagel.internal.render.texture.delete(e.internal.canvasID,e.game)}},trigger:!0},description:"A text sprite. Allows you to easily display text onscreen.",init:(e,t,n)=>{let i=e.internal;i.last={},i.needsRerender=!0,e.last={collision:null},e.internal.canvasID=".Internal.text."+e.id,i.canvas=document.createElement("canvas"),i.canvas.width=1,i.canvas.height=1,Bagel.internal.render.texture.new(e.internal.canvasID,e.internal.canvas,t,!1,"static"),i.ctx=i.canvas.getContext("2d"),n.vars.font.prerender(e,n,!0)},render:{onVisible:(e,t,n,i)=>{let r=e.internal;if(r.renderUpdate=!1,e.bitmap&&!0===e.game.get.asset.font(e.font))return;let a=n.internal.renderer.scaleX,s=n.internal.renderer.scaleY;return!r.needsRerender&&(e.bitmap||r.last.scaleX==a&&r.last.scaleY==s)||(r.needsRerender=!1,i.vars.font.prerender(e,i)),t({x:e.x,y:e.y,width:e.width,height:e.height,image:e.internal.canvasID,rotation:90,alpha:e.alpha},n,!1)},onInvisible:(e,t)=>t(e.internal.Bagel.renderID,e.game),whileVisible:(e,t,n,i,r,a)=>{e.game.internal.renderer.canvas;let s=r.internal.renderer.scaleX,o=r.internal.renderer.scaleY,l=e.internal;if(!l.needsRerender&&(e.bitmap||l.last.scaleX==s&&l.last.scaleY==o)||(l.needsRerender=!1,a.vars.font.prerender(e,a)),l.renderUpdate)return l.renderUpdate=!1,t(l.Bagel.renderID,{x:e.x,y:e.y,width:e.width,height:e.height,image:l.canvasID,rotation:90,alpha:e.alpha},r,!1)}}}}},methods:{bagel:{maths:{category:{capAngle:{fn:{normal:!0,fn:e=>1==Math.sign(e)?(e+180)%360-180:(e-180)%360+180}},radToDeg:{fn:{normal:!0,fn:e=>180*e/Math.PI}},degToRad:{fn:{normal:!0,fn:e=>e*(Math.PI/180)}},get:{category:{direction:{fn:{normal:!0,fn:(e,t,n,i)=>Bagel.maths.radToDeg(Math.atan2(i-t,n-e))+90}},distance:{fn:{normal:!0,fn:(e,t,n,i)=>Math.sqrt(Math.pow(Math.abs(n-e),2)+Math.pow(Math.abs(i-t),2))}}}},hex:{fn:{normal:!0,fn:e=>1==(e=e.toString(16)).length?"0"+e:e}}}},download:{fn:{obArg:!1,args:{data:{required:!0,types:["string"],description:"The data for the file. Or the data URL if isUrl is set to true"},fileName:{required:!0,types:["string"],description:"The file name for the file to be downloaded."},isURL:{required:!1,default:!1,types:["boolean"],description:"If the data is a URL or not. This may be useful if you want to download a canvas using .toDataURL()."},mime:{required:!1,default:"text/plain",types:["string"],description:"The MIME type for the file."}},fn:e=>{let t;if(e.isURL)t=e.data;else{let n=new Blob([e.data],{type:e.mime});t=window.URL.createObjectURL(n)}let n=document.createElement("a");n.download=e.fileName,n.href=t,(e=>{e.onclick=(()=>e.remove())})(n),n.style.display="none",document.body.appendChild(n),n.click()}}},upload:{fn:{obArg:!1,args:{handler:{required:!0,types:["function"],description:"The handler function. It's given the data URL of the file as its first argument and the second is the file number, starting at 0 (for use with the 2nd argument set to true)"},multiple:{required:!1,default:!1,types:["boolean"],description:"If multiple files can be uploaded or not. The handler will be called once per file."}},fn:e=>{let t=document.createElement("input");t.type="file",t.style.display="none",t.multiple=e.multiple,(e=>{let n=0;t.addEventListener("change",i=>{let r=new FileReader;r.onload=(i=>{e.handler(i.target.result,n),++n<t.files.length&&r.readAsDataURL(t.files[n])}),r.readAsDataURL(t.files[0])},!1)})(e),Bagel.internal.inputAction.queue(e=>{e.click()},t)}}},pwa:{category:{init:{fn:{obArg:!0,args:{worker:{required:!1,types:["string"],description:"The URL of the service worker. They can be generated using Bagel.pwa.generate.worker. Its arguments are the game, extra files (e.g js files) and an optional fileName for the worker that will be downloaded by it."},icons:{required:!1,default:!1,types:["boolean"],description:"If the icons exist or not. Generate them using Bagel.pwa.generate.icons."},manifest:{required:!1,types:["string"],description:"The href of the manifest. Generate one using Bagel.pwa.generate.manifest."},debugManifest:{required:!1,types:["string"],description:"The href of your debug manifest. It allows you to test your PWA without putting it on a production server. (don't test things on production! :P)"},versions:{required:!1,types:["string"],description:"The href of the version JSON file. Generate versions using Bagel.pwa.generate.version."},version:{required:!1,types:["string"],description:"The href of the version file (the one that contains the latest version name). Generate versions using Bagel.pwa.generate.version."},versionStorageName:{required:!1,types:["string"],description:'The name for the localStorage that contains the current downloaded version. e.g "Marble game version". localStorage is shared on a website so make sure the name is unique to this game. It\'s explained in Bagel.pwa.generate.version.'},cacheStorageName:{required:!1,types:["string"],description:"The cache storage name provided by Bagel.pwa.generate.worker."},multiTabStorageName:{required:!1,types:["string"],description:"A name unique to this page for detecting multiple instances of the game and preventing them. (don't forget that domains share localStorage)"},minified:{required:!1,default:!1,types:["boolean"],description:"If you've minified your main JavaScript file. You should also use the minified version of Bagel.js."},debug:{required:!1,default:!0,types:["boolean"],description:"If debug mode should be enabled. This disables the service worker so the page updates properly when reloading. Make sure you disable this before you put this game online though."}},fn:e=>{if(Bagel.internal.pwaInitialized&&console.error("Erm, you can only run this function once per page. The PWA's already initialized."),e.worker?navigator.serviceWorker&&(e.debug?navigator.serviceWorker.getRegistrations().then(e=>{for(let t of e)t.unregister()}):navigator.serviceWorker.register(e.worker)):console.warn("The Bagel.js service worker's missing. Generate one using Bagel.pwa.generate.worker."),e.icons||console.warn("The Bagel.js icons are missing. Generate the icons using Bagel.pwa.generate.icons."),e.manifest){let t=e.debug?e.debugManifest:e.manifest;if(null==e.debugManifest&&console.warn('No debug manifest specified. One should have been generated by Bagel.pwa.generate.manifest. Once you\'ve got it, link it to your game by setting the "debugManifest" argument in this function to its href.'),e.debugManifest||!e.debug){let e=document.createElement("link");e.rel="manifest",e.href=t,document.head.appendChild(e)}}else console.warn("The Bagel.js manifest is missing. Generate one using Bagel.pwa.generate.manifest once you've generated the icons using Bagel.pwa.generate.icons.");e.versions||console.warn("The Bagel.js version JSON file's missing. Use Bagel.pwa.generate.version."),e.version?navigator.onLine?e.versionStorageName&&e.versions&&e.cacheStorageName&&("undefined"==typeof caches?(console.error("Huh, looks like you're trying to run this on an insecure server (the traffic isn't encrypted). Browsers block cache storage for insecure websites for security reasons. If this is your test server, you can try connecting using the url 127.0.0.0:<port of your current url>. If this is your main server, you should be using HTTPS, it's 2020! :P"),Bagel.internal.oops(game)):fetch(e.version).then(t=>t.text().then(t=>{t=t.split("\n").join("");let n=localStorage.getItem(e.versionStorageName);null==n&&(n=0),Bagel.pwa.version=n,n!=t&&fetch(e.versions).then(t=>t.json().then(t=>{caches.open(e.cacheStorageName).then(i=>{let r=n;for(;n<t.versions.length;){let e=t.versions[n].changed;for(let t in e)i.delete(e[t]);n++}localStorage.setItem(e.versionStorageName,n),Bagel.pwa.version=n;let a=!1;Bagel.events.pwaUpdate&&(a=Bagel.events.pwaUpdate(n,r,t)),a||location.reload()})}))}))):console.log("You're offline."):console.warn("The Bagel.js latest version file's missing. Use Bagel.pwa.generate.version."),e.multiTabStorageName?(null==localStorage.getItem(e.multiTabStorageName)&&localStorage.setItem(e.multiTabStorageName,"0"),((t,n)=>{setTimeout(i=>{if(localStorage.getItem(e.multiTabStorageName)==t){setInterval(t=>{++n>100&&(n=0),localStorage.setItem(e.multiTabStorageName,n)},500)}else alert("Erm. Looks like you have two of the same tab open. Please close one. Data loss is possible if you continue.")},1e3)})(localStorage.getItem(e.multiTabStorageName),0)):console.warn("The Bagel.js multi tab storage name is missing. This is a name unique to this page for detecting multiple instances of the game and preventing them. (don't forget that domains share localStorage)"),e.versionStorageName||console.warn("The Bagel.js version storage name's missing. This is explained in Bagel.pwa.generate.version."),e.cacheStorageName||console.warn("The Bagel.js cache name's missing. This should've been added after running Bagel.pwa.generate.worker."),e.minified||console.warn("Your code isn't minified. Look up an online tool to help. Once you're done, set \"minified\" in Bagel.pwa.init to true. Also, make sure to run lighthouse or an equivalent so you can follow the best practices :)"),e.debug&&console.warn('PWA debug mode is enabled, make sure you disable it before releasing by setting "debug" in Bagel.pwa.init to false.'),Bagel.internal.pwaInitialized=!0}}},generate:{category:{worker:{fn:{obArg:!1,args:{game:{required:!0,types:["object"],description:"The game object."},icons:{required:!0,types:["string"],description:"The href of the folder containing the icons. Generate them with Bagel.pwa.generate.icons."},extraFiles:{required:!0,types:["array"],description:"Any extra files that aren't assets but are needed. e.g main.js, bagel.js etc. The index.html file is automatically included"},storageID:{required:!1,types:["string"],description:'The id for the cache storage the worker uses. Defaults to "Bagel.js" followed by a space and then the name of the game specified.'},manifest:{required:!1,default:"manifest.json",types:["string"],description:"The href of your manifest or what will be the href when the website is properly online."},worker:{required:!1,default:"worker.js",types:["string"],description:"The file name for the worker JavaScript file. Determines the name when it's downloaded but also the href of the file so it can be cached."}},fn:(e,t)=>{let n=e.extraFiles,i=t.internal.combinedPlugins.types.assets;for(let e in t.game.assets){let r=t.game.assets[e];for(let t in r)for(let a in i[e].hrefArgs){let s=r[t][i[e].hrefArgs[a]];if(null!=s){let e=s.split(":")[0];"data"!=e&&"blob"!=e&&n.push(s)}}}for(let e in t.game.plugins){let i=t.game.plugins[e].src,r=i.split(":")[0];"data"!=r&&"blob"!=r&&n.push(i)}"/"!=e.icons[e.icons.length-1]&&(e.icons+="/");let r=[128,144,152,192,256,512];for(let t in r)n.push(e.icons+r[t]+"x"+r[t]+".png");n.includes(e.manifest)||n.push(e.manifest),n.includes(e.worker)||n.push(e.worker);let a='let index=location.href.split("/");index.pop();const toCache=[index=index.join("/")+"/",...<CACHE>];self.addEventListener("install",e=>{self.skipWaiting()});const useCache=e=>cache?e():caches.open(<NAME>).then(s=>(cache=s,e()));let cache;self.addEventListener("fetch",e=>{e.respondWith(useCache(s=>cache.match(e.request).then(s=>{if(s)return s;{let s=fetch(e.request);return s.then(s=>{let t=e.request.url,n=t.replace(index,"");(t==index||toCache.includes(n))&&cache.put(e.request,s.clone())}),s.catch(s=>{console.warn("A Bagel.js service worker failed to fetch "+e.request.url+". Request:"),console.log({...e.request})}),s}})))});'.replace("<CACHE>",JSON.stringify(n));null==e.storageID&&(e.storageID="Bagel.js "+e.game.id),a=a.replace("<NAME>",JSON.stringify(e.storageID)),Bagel.download(a,e.worker,!1,"application/javascript"),console.log("Your service worker has been generated. Make sure to place this in the root directory of your project, also make sure that this page is in the root directory. You should also make sure that the array provided for the second argument contains the SRCs (not URLs!) of your JavaScript files (including the Bagel.js file).\nA new worker will need to be generated for each version (unless there's no new files) (versions can be generated using Bagel.pwa.generate.version)"),console.log('Make sure you enable the worker by setting the "worker" argument to '+JSON.stringify(e.fileName)+' and by setting "cacheStorageName" to '+JSON.stringify(e.storageID)+" in Bagel.pwa.init. You should also generate a version using Bagel.pwa.generate.version if you haven't already."),console.log("\nAlso make sure to save the code you used so you can generate the next worker more easilly.")}}},icons:{fn:{obArg:!1,args:{src:{required:!0,types:["string"],description:"The src of the 512x512 resolution icon. (it can be any resolution if it's pixel art)"},pixelArt:{required:!0,default:!0,types:["boolean"],description:"If the icon is pixel art or not. If it is, anti-aliasing will be disabled and there'll be no warning for having a low resolution icon."}},fn:e=>{let t=new Image;(t=>{t.onload=(n=>{t.width!=t.height&&console.warn("Huh, the image width doesn't match image height."),e.pixelArt||(t.width<512||t.height<512)&&console.warn("Hmm, the image resolution is less than 512x512 and it's not pixel art. It may appear blurry.");let i=document.createElement("canvas"),r=i.getContext("2d"),a=[128,144,152,192,256,512];for(let n in a){let s=a[n];i.width=s,i.height=s,r.imageSmoothingEnabled=!e.pixelArt,r.clearRect(0,0,i.width,i.height),r.drawImage(t,0,0,i.width,i.height),Bagel.download(i.toDataURL("image/png"),s+"x"+s+".png",!0)}console.log('128, 144, 152, 192, 256 and 512 pixel resolutions have been generated. You may need to enable automatic downloads. These should be in a folder in your project directory (or subfolder). You can add them to your PWA by generating a manifest. You should also make sure to set the "icons" argument in Bagel.pwa.init to true.')})})(t),t.src=e.src,console.log("Loading image...")}}},manifest:{fn:{obArg:!0,args:{icons:{required:!0,types:["string"],description:"The src of the folder containing the icons. Ending it in a slash is optional. Generate these using Bagel.pwa.generate.icons, give it the src of your highest resolution image followed by if it's pixel art or not."},name:{required:!0,types:["string"],description:"The name of your PWA. Usually the name shown in an app list."},shortName:{required:!0,types:["string"],description:"A shorter name."},startURL:{required:!0,types:["string"],description:"The URL for the PWA to start at when it's opened."},backgroundColor:{required:!1,types:["string"],description:"The background colour for the PWA. Is an HTML colour. Defaults to the page's background colour."},themeColor:{required:!1,types:["string"],description:"The theme colour for the app. See https://developer.mozilla.org/en-US/docs/Web/Manifest/theme_color"},categories:{required:!1,types:["array"],description:"Any categories your PWA fits into. e.g games."},description:{required:!1,types:["string"],description:"A brief description of what this PWA is or does."},dir:{required:!1,types:["string"],description:'The direction of the text. Probably not needed as the Bagel.js pwa creator only works for games and not websites with games in them. Either "auto", "ltr" or "rtl".'},display:{required:!1,default:"fullscreen",types:["string"],description:'The display mode for the PWA. Can be "fullscreen", "standalone", "minimal-ui" or "browser".'},iarcRatingId:{required:!1,types:["string"],description:"An id for if your website's been age rated or not."},lang:{required:!1,types:["string"],description:'The language of your PWA. e.g "en-UK".'},orientation:{required:!1,default:"any",types:["string"],description:'The default orientation for the PWA. Most of the time, you probably want to set this to "landscape" or leave it so it\'s "any".'},preferRelatedApplications:{required:!1,types:["boolean"],description:"Tells the browser to encourage users to install a similar app, e.g your native app instead. You probably won't want to use this."},relatedApplications:{required:!1,types:["array"],description:"See https://developer.mozilla.org/en-US/docs/Web/Manifest/related_applications"},screenshots:{required:!1,types:["array"],description:"Intended to be used by PWA stores. See https://developer.mozilla.org/en-US/docs/Web/Manifest/screenshots"},scope:{required:!1,types:["string"],description:"The different URLs that the manifest applies to. Defaults to your argument for the start URL, which is probably what you want most of the time."}},fn:e=>{let t={icons:"icons",name:"name",shortName:"short_name",backgroundColor:"background_color",themeColor:"theme_color",categories:"categories",description:"description",dir:"dir",display:"display",iarcRatingId:"iarc_rating_id",lang:"lang",orientation:"orientation",preferRelatedApplications:"prefer_related_applications",relatedApplications:"related_applications",scope:"scope",screenshots:"screenshots",startURL:"start_url"},n={};for(let i in e)null==e[i]?"backgroundColor"==i?document.body&&(n[t[i]]=document.body.bgColor):"scope"==i&&(n[t[i]]=e.startURL):n[t[i]]=e[i];"/"!=(e=n).icons[e.icons.length-1]&&(e.icons+="/");let i=[128,144,152,192,256,512],r=[];for(let t in i){let n=i[t],a=n+"x"+n;r.push({src:e.icons+a+".png",sizes:a,type:"image/png"})}e.icons=r;let a=Bagel.internal.deepClone(e);a.start_url=location.href,a.scope=location.href,Bagel.download(JSON.stringify(e),"manifest.json",!1,"application/json"),Bagel.download(JSON.stringify(a),"debugManifest.json",!1,"application/json"),console.log('Manifests generated. Put them in the root directory of your project and set the "manifest" argument in Bagel.init.pwa to normal manifest src. You should also set the "debugManifest" argument to the other manifest\'s src if you want to be able to test your PWA.'),console.log("(You might need to enable automatic downloads to get both the files)"),console.log("Tip: you should also save the code you just ran so you can update your manifest more easily."),console.log('\nYou should also add these elements to your HTML "head" tag if you haven\'t already...');let s=r[r.length-1].src,o=document.createElement("link");o.rel="icon",o.type="image/png",o.href=s;let l=document.createElement("p");l.appendChild(o),console.log(l.innerHTML),(o=document.createElement("link")).rel="apple-touch-icon",o.sizes="512x512",o.type="image/png",o.href=s,(l=document.createElement("p")).appendChild(o),console.log(l.innerHTML)}}},version:{fn:{obArg:!1,args:{name:{required:!0,types:["string"],description:"The name of this version. e.g 1.0"},changed:{required:!0,types:["array"],description:"The srcs of files that have changed. This should include removed files but not new files. A rename should be treated as a removed file and then a new file. If you regenerated your worker file or manifest, it should also be included. If this is your first version, this should be empty."},versions:{required:!1,default:{syntax:1,versions:[]},types:["object"],description:"The current version JSON."},fileName:{required:!1,default:"versions.json",types:["string"],description:"The file name for the versions JSON file."}},fn:e=>{let t=0!=e.versions.versions.length;e.versions.versions.push({name:e.name,changed:e.changed}),Bagel.download(JSON.stringify(e.versions),e.fileName,!1,"application/json"),t||1==parseFloat(e.name)||console.warn("No previous version JSON was specified and this doesn't appear to be the first version.\nIf this isn't the first version, rerun this with the 3rd argument set to your current version JSON (not as a string)."),console.log("New version file generated. If there was no warning or you think it's incorrect, you should now "+(t?"replace your existing versions.json file":"move this file into your root directory")+"."),t?console.log("Don't forget to update your version file with\n"+JSON.stringify(e.versions.versions.length)+" :)"):(console.log('You also need a file to specifiy what the latest version is. Create a plain text file called "version.txt" in your root directory and put '+JSON.stringify(e.versions.versions.length)+" in it. New lines will be ignored."),console.log('Finally, link these two into your PWA by setting the "versions" and "version" arguments in Bagel.pwa.init to their corresponding file srcs, "versionStorageName" should also be set to something unique to the game (it\'s where the installed version is saved). If you\'ve followed all the other steps properly, your PWA should now be working. (make sure you\'re running on an HTTPS server or localhost)'))}}}}},help:{fn:{normal:!0,fn:e=>{console.log("Full tutorial here: https://github.com/hedgehog125/Bagel.js/wiki/PWA-Tutorial :)")}}}}},font:{category:{create:{fn:{fn:e=>{const t=t=>{let n=document.createElement("canvas");n.width=t.width,n.height=t.height;let i=n.getContext("2d");i.drawImage(t,0,0);let r=i.getImageData(0,0,n.width,n.height),a=[],s=0,o=0;for(;o<r.data.length;){let e=255==r.data[o]&&255==r.data[o+3],t=o+4*r.width>=r.data.length;if(e||t){let e=Math.floor(o/4/r.width);a.push(e-s+t),s=e+1,0}o+=4*r.width}let l=[],d="",u=0;for(o=0,s=0;o<r.data.length;){let e=o/4%r.width;if(y=Math.floor(o/4/r.width),y==s)u++;else if(e==u){o=(y+1)*(4*r.width);continue}if(0==r.data[o+3])d+="0";else{if(255==r.data[o]){0==e?(l.push(u),u=0,s=y+1,o+=4*r.width):(o=(Math.floor(o/4/r.width)+1)*(4*r.width),u--);continue}d+="1"}o+=4}l.push(u);let g=JSON.stringify({widths:l,heights:a,pixels:d});return e.download&&Bagel.download(g,"font.bagelFont"),g};if(void 0!==e.img)return t(e.img);Bagel.upload(e=>{let n=new Image;n.onload=(e=>{t(e.target)}),n.src=e}),console.log("Click on the game to open the file picker.")},args:{img:{required:!1,types:["object"],description:"The image of the new font. Either a HTML image object or blank to upload one."},download:{required:!1,default:!0,types:["boolean"],description:"If the resulting font file should be downloaded or only returned as a string."}}}}}}},game:{playSound:{fn:{obArg:!1,args:{id:{required:!0,types:["string"],description:"The id of the sound to play."},volume:{required:!1,default:1,types:["number"],description:"The volume to play the sound at."},loop:{required:!1,default:!1,types:["boolean"],description:"If the audio should loop or not."},startTime:{required:!1,default:0,types:["number"],description:"The starting time for the audio in seconds."},restart:{required:!1,default:!1,types:["boolean"],description:"If the sound should restart or not if it's already playing. If false and it's already playing, nothing will happen and the sound will continue."}},fn:(e,t,n)=>{let i=e.get.asset.snd(t.id);if((i.paused||t.restart)&&(i.currentTime=t.startTime,i.loop=t.loop,i.volume=Math.max(Math.min(t.volume,1),0),n.vars.audio.autoPlay)){let r=i.play();null!=r&&(n=>{r.then(e=>{n.vars.audio.autoPlay=!0}).catch(r=>{let a=Bagel.internal.current;Bagel.internal.saveCurrent(),a.plugin=n,n.vars.audio.autoPlay=!1,n.vars.audio.createUnmute(n,e),(t.loop||i.duration>=5)&&n.vars.audio.queue.push(t.id),Bagel.internal.loadCurrent()})})(n)}}}},stopSound:{fn:{obArg:!1,args:{id:{required:!0,types:["string"],description:"The id of the sound to stop."}},fn:(e,t,n)=>{Bagel.get.asset.snd(t.id,e).stop()}}},debug:{category:{textures:{category:{showCombined:{fn:{obArg:!1,args:{index:{required:!0,types:["number"],check:(e,t,n,i,r,a)=>{let s=i.internal.renderer.textureSlots,o=s[e];if(null==o||null==o.canvas&&null==o[3])return"Huh, that combined texture doesn't seem to exist, hasn't been activated yet or was empty when it was deactivated. Make sure the index is between 0 and "+(s.length-1)+". Also make sure that that combined texture has been activated."},description:"The index number of the combined texture or single texture to display."},mini:{required:!1,default:!0,types:["boolean"],description:"If the texture map should be small and visible alongside the game or fill the screen."}},fn:(e,t,n)=>{"webgl"!=e.internal.renderer.type&&(console.error('Oh no! This function only works on games that are using the "webgl" renderer. Textures aren\'t combined in the other renderers.'),Bagel.internal.oops(e));let i=e.internal.renderer.textureSlots[t.index];t.mini?i.canvas.style="display:block;touch-action:none;user-select:none;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);border:1px solid black;background-color:white;position:absolute;top:0px;left:0px;z-index:1;":i.canvas.style="display:block;touch-action:none;user-select:none;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);margin:0;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);border:1px solid black;";let r=i.canvas?i.canvas:i[3];Bagel.internal.tryStyles(r,"image-rendering",["pixelated","optimize-contrast","-moz-crisp-edges","-o-crisp-edges","-webkit-optimize-contrast","optimizeSpeed"]);let a=window.innerWidth,s=window.innerHeight;return a>s?a=s:s=a,t.mini?(r.style.width=a/4-2+"px",r.style.height=s/4-2+"px"):(r.style.width=a-2+"px",r.style.height=s-2+"px"),r.className="Bagel-debug-combinedTextureCanvas",r.id="Bagel-debug-combinedTextureCanvas-"+e.id+"-"+t.index,i[0]?console.log("This texture or combined texture is currently innactive but here's the contents of its canvas."):console.log("Also, here's some info about this "+(i.singleTexture?"single texture":"combined texture")+":\nSingle texture: "+i.singleTexture+"\n"+(i.singleTexture?"":"Texture count: "+i.textureCount+"\n")+"Resolution: "+r.width+"x"+r.height+"\nGL context active: "+(null!=i.gl)+"\n"),!document.querySelector("Bagel-debug-combinedTextureCanvas#"+r.id)&&(document.body.appendChild(r),t.mini||(e.internal.renderer.canvas.hidden=!0,e.internal.renderer.canvas.style.display=""),!0)}}},hideCombined:{fn:{obArg:!1,args:{index:{required:!0,types:["number"],check:(e,t,n,i,r,a)=>{let s=i.internal.renderer.textureSlots,o=s[e];if(null==o||null==o.canvas)return"Huh, that combined texture doesn't seem to exist. Make sure the index is between 0 and "+(s.length-1)+". Also make sure that that combined texture has been activated."},description:"The index number of the combined texture or single texture to hide."}},fn:(e,t,n)=>{"webgl"!=e.internal.renderer.type&&(console.error('Huh, this function only works on games that are using the "webgl" renderer. Textures aren\'t combined in the other renderers.'),Bagel.internal.oops(e));e.internal.renderer.textureSlots[t.index];let i="Bagel-debug-combinedTextureCanvas-"+e.id+"-"+t.index,r=document.querySelector(".Bagel-debug-combinedTextureCanvas#"+i);return!!r&&(document.body.removeChild(r),0==document.getElementsByClassName("Bagel-debug-combinedTextureCanvas").length&&(e.internal.renderer.canvas.hidden=!1,e.internal.renderer.canvas.style.display="block"),!0)}}},listDownscaled:{fn:{obArg:!1,args:{},fn:(e,t,n)=>{"webgl"!=e.internal.renderer.type&&(console.error('Hmm, this function only works on games that are using the "webgl" renderer. Textures don\'t ever need to be downscaled in the other renderers.'),Bagel.internal.oops(e));let i=e.internal.renderer;if(0==Object.keys(i.downscaled).length)console.log("No textures have had to be downscaled yet."),"canvas"==e.config.display.renderer&&console.log("However, since you're using the \"canvas\" renderer at the moment, textures don't ever need to be downscaled.");else{console.log("These textures were downscaled this many times (including the initial texture if it was over the limit):");for(let e in i.downscaled)console.log(e+": "+i.downscaled[e])}}}},listAnimatedIntoCombined:{fn:{obArg:!1,args:{},fn:(e,t,n)=>{"webgl"!=e.internal.renderer.type&&(console.error('Oh no! This function only works on games that are using the "webgl" renderer. Textures don\'t ever need to be downscaled in the other renderers.'),Bagel.internal.oops(e));let i=e.internal.renderer;if(0==Object.keys(i.animatedIntoCombined).length)console.log("No animated textures have had to use a combined texture yet."),"canvas"==e.config.display.renderer&&console.log("However, since you're using the \"canvas\" renderer at the moment, the texture modes don't matter.");else{console.log("These animated textures became combined textures:");for(let e in i.animatedIntoCombined)console.log(e)}}}}}}}}},sprite:{move:{fn:{appliesTo:["sprite","canvas"],obArg:!1,args:{amount:{required:!0,types:["number"],description:"The number of in game pixels (independent of the rendered canvas width and height) to move the sprite."},angle:{required:!1,types:["number"],description:"The angle in degrees for the sprite to move in. 0ยฐ -> Straight up. -180/180ยฐ -> Straight down. 90ยฐ -> Right (default of sprites). Defaults to the value of sprite.angle."}},fn:(e,t,n)=>{let i=e.internal.cache;if(null==t.angle)e.x+=i.sin*t.amount,e.y-=i.cos*t.amount;else{let n=Bagel.maths.degToRad(t.angle);e.x+=Math.sin(n)*t.amount,e.y-=Math.cos(n)*t.amount}}}},layer:{category:{bringToFront:{fn:{appliesTo:["sprite","canvas","text"],obArg:!1,args:{},fn:(e,t,n)=>{null!=e.internal.Bagel.renderID&&Bagel.internal.render.bitmapSprite.bringToFront(e.internal.Bagel.renderID,n)}}},bringForwards:{fn:{appliesTo:["sprite","canvas","text"],obArg:!1,args:{},fn:(e,t,n)=>{null!=e.internal.Bagel.renderID&&Bagel.internal.render.bitmapSprite.bringForwards(e.internal.Bagel.renderID,n)}}},sendToBack:{fn:{appliesTo:["sprite","canvas","text"],obArg:!1,args:{},fn:(e,t,n)=>{null!=e.internal.Bagel.renderID&&Bagel.internal.render.bitmapSprite.sendToBack(e.internal.Bagel.renderID,n)}}},sendBackwards:{fn:{appliesTo:["sprite","canvas","text"],obArg:!1,args:{},fn:(e,t,n)=>{null!=e.internal.Bagel.renderID&&Bagel.internal.render.bitmapSprite.sendBackwards(e.internal.Bagel.renderID,n)}}}}},touching:{category:{mouse:{fn:{appliesTo:["sprite","canvas","text"],obArg:!0,args:{box:{required:!1,types:["object"],subcheck:{x:{required:!0,types:["number"],description:"The x position of the middle of the bounding box."},y:{required:!0,types:["number"],description:"The y position of the middle of the bounding box."},width:{required:!0,types:["number"],description:"The width of the bounding box."},height:{required:!0,types:["number"],description:"The height of the bounding box."}},description:"The bounding box to be used. If unspecified, the sprite's width, height, x and y coordinates will be used to make one."},mouseSize:{required:!1,default:0,types:["number"],description:"The size of the bounding box for the mouse. Defaults to one pixel."},mode:{required:!1,default:"touching",check:e=>{if(!["touching","overlap"].includes(e))return'Huh, looks like you used an invalid option for the "mode" argument. It can only be "touching" or "overlap" and you put '+JSON.stringify(e)+"."},description:'The touching mode. Defaults to "touching" but can also be "overlap".'}},fn:(e,t,n)=>{null==t.box?t.box={x:e.x-Math.abs(e.width/2),y:e.y-Math.abs(e.height/2),width:Math.abs(e.width),height:Math.abs(e.height)}:(t.box.x-=e.width/2,t.box.y-=e.height/2),"touching"==t.mode&&(t.box.width+=2,t.box.height+=2,t.box.x--,t.box.y--);let i,r=t.mouseSize/2;i=Bagel.device.is.touchscreen?n.input.touch.touches:[{x:n.input.mouse.x,y:n.input.mouse.y}];let a=t.box;for(let t in i){let n=i[t];if(n.x-r<a.x+a.width&&n.x+r>a.x&&n.y-r<a.y+a.height&&n.y+r>a.y)return e.last.collision={x:n.x,y:n.y,type:"mouse"},!0}return!1}}},mouseCircles:{fn:{appliesTo:["sprite","canvas","text"],obArg:!0,args:{radius:{required:!1,types:["number"],description:"The radius of the bounding box. If unspecified, the sprite's width and height will be used to make one."},mouseRadius:{required:!1,default:1,types:["number"],description:"The radius of the bounding box for the mouse. Defaults to one pixel."},mode:{required:!1,default:"overlap",check:e=>{if(!["touching","overlap"].includes(e))return'Huh, looks like you used an invalid option for the "mode" argument. It can only be "touching" or "overlap" and you put '+JSON.stringify(e)+"."},description:'The touching mode. Defaults to "overlap" but can also be "touching".'}},fn:(e,t,n)=>{let i,r={x:e.x,y:e.y};null==t.radius?r.radius=Math.max(Math.abs(e.width),Math.abs(e.height))/2:r.radius=t.radius,"touching"==t.mode&&r.radius++,i=Bagel.device.is.touchscreen?n.input.touch.touches:[{x:n.input.mouse.x,y:n.input.mouse.y}];let a=t.mouseRadius+r.radius;for(let t in i){let n=i[t];if(Math.sqrt(Math.pow(Math.abs(r.x-n.x),2)+Math.pow(Math.abs(r.y-n.y),2))<=a)return e.last.collision={x:n.x,y:n.y,type:"mouse"},!0}return!1}}},sprite:{fn:{appliesTo:["sprite","canvas","text"],obArg:!1,args:{sprite:{required:!0,types:["string"],description:"The id of the sprite to check against for a collision."},options:{required:!1,default:{},subcheck:{box:{required:!1,types:["object"],subcheck:{x:{required:!0,types:["number"],description:"The x position of the middle of the bounding box."},y:{required:!0,types:["number"],description:"The y position of the middle of the bounding box."},width:{required:!0,types:["number"],description:"The width of the bounding box."},height:{required:!0,types:["number"],description:"The height of the bounding box."}},description:"The bounding box to be used. If unspecified, the sprite's width, height, x and y coordinates will be used to make one."},mode:{required:!1,default:"overlap",types:["string"],check:e=>{if(!["touching","overlap"].includes(e))return'Huh, looks like you used an invalid option for the "mode" argument. It can only be "touching" or "overlap" and you put '+JSON.stringify(e)+"."},description:'The touching mode. Defaults to "overlap" but can also be "touching".'},include:{required:!1,default:{},types:["object"],subcheck:{clones:{required:!1,default:!0,types:["boolean"],description:"If this collision check includes clones or not."},invisibles:{required:!1,default:!1,types:["boolean"],description:"If this collision check includes invisible sprites or not."}},description:"A few options for whether or not some sprites should be included in the checks."}},types:["object"],description:"A few other options for this function."},check:{required:!1,types:["function"],description:"A function that does an additional check before a collision is reported. It's given the sprite that's being checked against, the current sprite and the game. (in that order)"}},fn:(e,t,n)=>{null==t.options.box?t.options.box={x:e.x-Math.abs(e.width/2),y:e.y-Math.abs(e.height/2),width:Math.abs(e.width),height:Math.abs(e.height)}:(t.options.box.x-=e.width/2,t.options.box.y-=e.height/2);let i=t.options.box;"touching"==t.options.mode&&(i.width+=2,i.height+=2,i.x--,i.y--);let r=[t.sprite],a=Bagel.get.sprite(t.sprite,n);if(t.options.include.clones){r.push(...a.cloneIDs);let t=r.indexOf(e.id);-1!=t&&r.splice(t,1)}let s=null==t.check;for(let a in r){let o=n.get.sprite(r[a]);if(!t.options.include.invisibles&&!o.visible)continue;let l=o.x-Math.abs(o.width/2),d=o.y-Math.abs(o.height/2);if(i.x<l+Math.abs(o.width)&&i.x+i.width>l&&i.y<d+Math.abs(o.height)&&i.y+i.height>d&&(t.check&&(s=t.check(o,e,n)),s))return e.last.collision={sprite:o,type:"sprite"},!0}return!1}}}}}}},listeners:{prepState:(e,t)=>{let n=t.internal.scripts.index.sprites.init[e];if(null==n)return;for(let i in n){let r=n[i].sprite;if("sprite"==r.type&&r.img&&Bagel.get.asset.img(r.img,t,!0),"text"==r.type&&r.bitmap&&t.get.asset.font(r.font),r.request&&r.request[e])for(let n in r.request[e]){let i=t.internal.combinedPlugins.types.assets[n];null==i&&(console.error("Oops, the (plural) asset type "+JSON.stringify(n)+" doesn't exist in this game."),console.log("These are the only types:"),console.log(Object.keys(t.internal.combinedPlugins.types.assets).join("\n")),Bagel.internal.oops(t)),i=i.get;for(let a in r.request[e][n])Bagel.get.asset[i](r.request[e][n][a],t,!0)}}let r=t.internal.assets.assets.snds;if(r)for(i in r)r[i].pause()}}},vars:{audio:{autoPlay:!0,queue:[],queueInputAction:(e,t)=>{((e,t)=>{Bagel.internal.inputAction.queue(n=>{setTimeout(n=>e.vars.audio.unmuteInputAction(e,t),15)})})(e,t)},unmuteInputAction:(e,t)=>{let n=Bagel.get.sprite(".Internal.unmute",t,!0);if(n){let i=n.vars;if(i.buttonClicked){let r=e.vars.audio.queue;if(0==r.length){((e,t,n,i)=>{e.play().catch(t=>{e.pause(),i.vars.audio.autoPlay=!1}).then(t=>{e.pause(),i.vars.audio.queue=[],i.vars.audio.autoPlay=!0,n.img=".Internal.unmuteButton"})})(Bagel.get.asset.snd(".Internal.unmuteButtonClickUp",t),0,n,e)}else for(let i in r){((e,t,n,i)=>{e.play().catch(t=>{e.pause(),i.vars.audio.autoPlay=!1}).then(e=>{i.vars.audio.queue=[],i.vars.audio.autoPlay=!0,n.img=".Internal.unmuteButton"})})(Bagel.get.asset.snd(r[i],t),0,n,e)}i.buttonClicked=!1}e.vars.audio.queueInputAction(e,t)}},createUnmute:(e,t)=>{if(!Bagel.get.sprite(".Internal.unmute",t,!0)){e.vars.audio.queueInputAction(e,t);let n='plugin Internal\'s function "game.playSound"';t.add.asset.img({id:".Internal.unmuteButtonMuted",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUEAYAAADdGcFOAAAABmJLR0QA/wAAAAAzJ3zzAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AUECgYpH/xRLwAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAFGSURBVEhLpVbbtcMwCCs9d4brjbJzvVGmcD9clQBRIY4+mtgRWBZ+VB5LGCNjnEMkY1DMIdnA6PfPKtbjw4wg9HyusXeMMSrDiYhotI/gzpIPOugMPaauCcowBedCXUcM0NKPcfTVDiCyKjwT+vQBnqDCZqLzhDkQZ0uNimjPtm/7tof8cfHCEesM3q/wbTvje55zMD8GwKh66B1jmEKjk3/nRLY2FFaols4PdBdkDdaBXa7bpeZYFbcFAt7RX9wroAJtqXJPwPeO3oUTGNPaXZZD1zDa+vsLbM0/8dkSPe364l91dO5ebZMS83RrQvF2vJkmmHO99dabCD0Hs2PmqlAF4mx+7xyQXnU1oexrBPKxAx/OffmPEtjmyR1kE/SOvf57603P1W+8D2TA1TNnmLEjWAm9Y3rgf54xpAbyryOFF8SAzG9tVk73YdUDkgAAAABJRU5ErkJggg=="},n),t.add.asset.img({id:".Internal.unmuteButton",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUEAYAAADdGcFOAAAABmJLR0QA/wAAAAAzJ3zzAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AUECgoeC/S7LAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAElSURBVEhLrZbREYQgDETNFaEdac3akTaR+2D2lODOBs/3w4gbWEJAbXiEu1LcY6YUkWRAa2je533e9YTbtE3bxBak44XgHJgZWsd1XMfY27Icy7EczDA3Sl5wY1lDCjMzM230Uz/mjWGC0g7duLu7x8i2FILBvLEYp2ALikbL/M346HAvAgSebdTVLdffx2fHv2Qweyp7yZZAMdpmstlibGm9JXpLs7peGoP/ks1YltcNvg01WNeEzkmsobf4GWSfpPqUaXr1gNXwB6/RgU9SpDdDvXqAa45w3kPIBGtrPdfdx/H7L17UoQbPFatro0zQnyEYi+OzzKX/Zp4aiihj5SxcEjWkYIdHG2Y7oYwBOQFAbZSBlLqFbSEzBtIGI+SvQ6IMRb66bmr2BeoT1QAAAABJRU5ErkJggg=="},n),t.get.asset.img(".Internal.unmuteButton"),t.add.asset.snd({id:".Internal.unmuteButtonClick",src:"data:audio/mpeg;base64,//OAxAAAAAAAAAAAAFhpbmcAAAAPAAAAAwAABBIAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBg0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ////////////////////////////////////////////AAAAUExBTUUzLjk5cgRuAAAAAAAAAAA1CCQCzSEAAeAAAAQSSYAuqwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zoMQAEnACyvdAAACoh3exu8jLeoIAgcKAgCAYLggCAIHCgIAhggGIPv5cEFg+D+sH/Lg4CHDHKHP/E4PghrBwMcEAQygY//BB3//+UBAEAx/KAhlAQcmYqIp0mTVUZDWGgyrJEUQYImG/BhWy0KoEQVVjZUyyAxi+zMxAcDuX+WiWnPTQwFZ4BkIgoSlO0HWRLRa6sZiyXtxgTnQ+IAlwFSpHstGDFzlpJ1J2pzS2mZiuluTRlbS2DUE23jTFgFMVrERfV4GUv7edHTZbTQ3CYA37KYccp4lAmlpzMpkEOspbRYs7LIi8j8MQbxBMzxd8NvvB7KbTgw4yl1W5P67sEQS7sYhl3Zx/ZbS7xUzi6X+TZJFYkkYszmT+NETCdJdz7uFIpTWyjsNSdyauojEpdBNNLm408Oz/87DE4loUgqsfmMAkgxuzs47j+VGWS1u8Uf913bjdZa8ehyAaaIu7EXJhhwZC4VK+0ifZr0F/j++Y/vHW6WVZwzAUWZ7FrTIbUonIxGL0OUt+9G5e5cXmm3gp+aBnEQfaROjKqF/Zl/ZQ+smaVSuk8zSmJNFZVG2Gv9BMO/dpccfkF6/er5y/LC67MYfWchq4/0fVrKAIu7lfHLva4zAQE2q//1VFBQEBKMzKuGAhVCgJqs+qAnVAVL/6vxmKMx///9VTqr/V9VXjMUZvgYCAQNP9YKrBX8S8ShsSgrEVZ0RBwRPg1Bp5U7rBUeGpUNiU78RBwRPUIoilTusFR4KqTEFNRTMuOTkuM6qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/zYMTZGtmybx/DGACqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg=="},n),t.add.asset.snd({id:".Internal.unmuteButtonClickUp",src:"data:audio/mpeg;base64,//OAxAAAAAAAAAAAAFhpbmcAAAAPAAAABAAABMkATk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnfn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn/////////////////////////////////AAAAUExBTUUzLjk5cgRuAAAAAAAAAAA1CCQDLCEAAeAAAATJpqKjmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zoMQAFogGux9BAAC6qruoVWtAv0iG8oCDgQcUBA4Jz8pLg+D+IAQd5cHwfB/rP/BAEDkoGPxACYPg+D5+GPUCAIA+/8HwQBAEAQBMH/h/8EAQBB3UCAPg+H/wQDH8HwfD8uD4Pg+qushml2hmlAYBrCAMEjTYbZgXKSJMQKAAkRyGgr9CoNCahLjLRnVAAhorQiAL13knoq8qAdYdH1rCt6FqmTC2dsHT1HCMoc2jWLUjdBRNoyJv4RMO0+0ZrvFNRFbrNnkWi/kVZar+lnZySwWwG4+ixJ1YkCQ+8pbp5BEMtK0x06WUrt+hjNymv+3B3YjhSwzfl+pU8dytnvDLdWPVbMpuUdPNWprdLVi9irfi0sqU17Ofj8Oyrct1AT9y2td13+c+7WpqbfJqlpatarGeX5Xf7rD/86DE0Up0bqMfmsAAw5zWN6btVKDKzU7yzzKbyps6amyrU1/uWWOOP8paa13k1DVLjTV7tumz7llnhjZyws6t1pfMyHcons7H42c6avS27mprVaNVbUzS/vdL3u/5l3+5fv7N/qaMNZRoSaM02g0LO2aTFcDsQUEAsfvVoGoStQqLLLRgFURCVLcDdYiz5huShkdWIiu/qVSyzERIxDHQ0pUtZNFTUECvRA6UymyVysMPMABBJfQHFAUZwC8TIEEyk3udBhrpMhGCRxJYZOULpBco1Sk7HGyX0/l6VsgUOZnGH2U2MI0A8GLUeKwWfCoQ8E0F/6BprcYalVlOdmj4tNyf6VXuLTLIuC/LorRbMhlMYw1BN2yzJs8dd2zGcZmTN3lUWlUzOQ3H4CpuPEw6G8qsZxtNxgFx//OwxNNQVC56/5jICGCqtSrclTdpucj0tjkRoKGIwTcd2njO6CtVptyqNXJuK0t2kpst61lv+a139Y6nN092prC19Ncls5QzfIlc3CL8BS+tasZXvm3RityJRaIxGw+0pj0Na7jvWWst/v//////UpprXcqYjJN1BQCkqkxBTUUzLjk5LjOqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/8xDE8QAAA/wBwAAAqqqqqqqqqqqqqqqqqg=="},n),t.add.asset.snd({id:".Internal.unmuteButtonMouseTouch",src:"data:audio/mpeg;base64,//OAxAAAAAAAAAAAAFhpbmcAAAAPAAAABAAABP0ASkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlfn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn/////////////////////////////////AAAAUExBTUUzLjk5cgRuAAAAAAAAAAA1CCQDKiEAAeAAAAT9uAw0pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zoMQAEjkqnedDMACyMBL0ufxEQvkRC3REREKgYACCEe7JpkEIy7Jp3Ed7Jp3vezyad7+9nkyd7BMmH8uf8Tg+8uD4f/l///Ln/5d//h///rB9//g+z7q7iFlKYTSjQDSknrKLQgSoGlObS2JMhgJeYvuY7AQqCdmwWOKDMmn7BoHzfVVVDBTsLMmppKqLp0vOKCTvSCZkpdHXbYjEnpVuWSqo6TdY6z5ur2PA3FrEqV1EYgu8tyumPPoyarCXtXFGr8QhiZqr8pX8uxX4koFKn9eB8HDaw7rWJFKXioqVfzRW6vxFrMeu5RKAaDjxU8JmvtRDCV2s7eEsvZyCV49gGxGsaOrQvzT1XFsZczpYai2PYeyq3GyRSXSh3n8sSyN237rWKSKdhqLdhtiVC9kzIIlEpq69DRb/86DE406karb/mMAFHbtWq4NWxKsdSq9Wpq3JuxT27ff5X7T3+U+X2/yntXm4vk5WpFjMzsGWX6qVJdG5dlTRyHoL7Wz/Gl7rKm3KvrV8cfpr8Zw5vm+/vt/G9V5re6lXCtV5KptKs5xLtdN7LRLNNperiCirq5ChNOZN0QkNyLgShrjSgaOXwEQpl1LzMZFtXeJAWG2ugwCMCNzUA833wAgJFXiAwSlUnkYugAJmMGF1gGAPCykUA0eGnu4YEOjRSYWOGAildqzYmsuUy5iUvmJQAQcyg7MCIzJAUw00r8huy/cNv9U28b9Oy0iBBCHGPhRiiWYIThCaZeuGOoyQ7WYu15yXHdWd9Z6msOrSf+Mpywm2TF6mlNJAaDCEAQJmBCbMc6sImYkzqn5TydmE5FtTFmXQHCpN//PAxNRcDG6O/5nYDVKDH5bfR9WU0pr5ggqBA8oDTAQqCi/xcpSpqVz8LlBLOfbs5VZXujdmZpdX5qLSKjpb0upn9qw66lmtflMqp05X1a6/rouqyKIwwBQqKvq+Evp6ksmbcY7m78VoYzhVr5T7cG3l0W5dptdpH/ll+zVtWfx5LUJyri9r6yHdWgjThQG12U2M5TSRrGgXNn3///3/P////99pfGdgs1VMQU1FVUxBTUUzLjk5LjNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//MQxPIAAAP8AcAAAFVVVVVVVVVVVVVVVVU="},n);let i=Math.min(t.width,t.height)/10;t.add.sprite({id:".Internal.unmute",type:"sprite",img:".Internal.unmuteButtonMuted",visible:!1,scripts:{steps:{appearAnimation:e=>{e.vars.delay<30?e.vars.delay++:(e.visible=!0,e.width!=e.vars.size&&(e.width*=1.4,e.width>=e.vars.size&&(e.width=e.vars.size,e.vars.appearAnimation=!1),e.height=e.width))},deleteAnimation:e=>{e.width/=1.4,e.height=e.width,e.width<1&&e.delete()},expandAnimation:e=>{e.width*=1.025,e.width>e.vars.expandedSize&&(e.width=e.vars.expandedSize),e.height=e.width},shrinkAnimation:e=>{e.width!=e.vars.size&&(e.width/=1.025,e.width<e.vars.size&&(e.width=e.vars.size),e.height=e.width),e.vars.plugin.vars.audio.autoPlay&&(e.vars.delete=!0)},play:e=>{e.vars.buttonClicked=!0},pause:e=>{let n=e.vars.plugin.vars;for(let e in t.internal.assets.assets.snds){let i=t.internal.assets.assets.snds[e];i.paused||(i.pause(),i.loop||i.duration>=5?n.audio.queue.push(e):i.currentTime=0)}n.audio.autoPlay=!1,e.img=".Internal.unmuteButtonMuted"}},all:[(e,t,n)=>{if(e.layer.bringToFront(),e.vars.appearAnimation)n("appearAnimation");else{t.input.mouse.down||(e.vars.clicked&&t.playSound(".Internal.unmuteButtonClickUp"),e.vars.clicked=!1);let i=e.vars.plugin.vars;e.vars.delete?n("deleteAnimation"):e.touching.mouseCircles()?(e.vars.touching||(t.playSound(".Internal.unmuteButtonMouseTouch"),e.vars.touching=!0),e.width!=e.vars.expandedSize&&n("expandAnimation"),t.input.mouse.down&&!e.vars.clicked&&(t.playSound(".Internal.unmuteButtonClick"),i.audio.autoPlay?n("pause"):n("play"),e.vars.clicked=!0)):(e.vars.touching=!1,n("shrinkAnimation"))}}]},vars:{plugin:e,size:i,expandedSize:1.1*i,delay:0,clicked:!1,delete:!1,touching:!1,appearAnimation:!0,buttonClicked:!1},x:i,y:t.height-i,width:1,height:1},'plugin Internal, function "game.playSound" (via Game.add.sprite)')}}},sprite:{updateAnchors:(e,t,n)=>{let i=e.internal.Bagel.properties;if(t&&"centered"!=i.x){t=i.x;let n=Math.abs((i.hasOwnProperty("width")?i.width:e.width)/2);isNaN(n)?(i.left=t,i.right=t):(i.left=t-n,i.right=t+n)}if(n&&"centered"!=i.y){n=i.y;let t=Math.abs((i.hasOwnProperty("height")?i.height:e.height)/2);isNaN(t)?(i.top=n,i.bottom=n):(i.top=n-t,i.bottom=n+t)}},resetCrop:(e,t)=>{let n=e.internal.Bagel.properties.crop;n.x=0,n.y=0,n.width=t.width,n.height=t.height,e.internal.renderUpdate=!0,e.internal.crop=!1}},font:{characterSets:{66:"abcdefghijklmnopqrstuvwxyz0123456789?!ยฃ$%^&*()+-_=:;'\".,/\\><~|[]{}"},top:{"'":1,'"':1,"^":1,"*":1},bottom:{".":1,",":1,_:1},prerender:(e,t,n)=>{let i=e.game,r=i.internal.renderer,a=r.scaleX,s=r.scaleY,o=e.internal,l=n?null:o.indexes,d=o.canvas,u=o.ctx,g=e.text.split("\n"),h=e.bitmap?t.vars.font.prerenderBitmap(g,e,a,s,t,d,u,n,l):t.vars.font.prerenderNonBitmap(g,e,a,s,d,u,n,l);h&&(o.indexes=h),0==d.width&&(d=i.internal.renderer.blankTexture),Bagel.internal.render.texture.update(o.canvasID,d,i),t.vars.sprite.updateAnchors(e,!0,!0),o.renderUpdate=!0},prerenderBitmap:(e,t,n,i,r,a,s,o,l)=>{let d=t.game.get.asset.font(t.font),u=r.vars.font.characterSets[d.widths.length],g=0,h=t.wordWrapWidth,c=2.5*Math.max(d.widths);null!=h&&h<c&&(h=c);let p,f,m=t.size/((d.avgWidth+d.avgHeight)/2)/2;if(h/=2*m,l)p=t.width/m,f=t.height/m;else{l=[];let n,i=0;for(;i<e.length;){l.push([]),n=0,text=e[i].toLowerCase();let r=!1,a=0,s=0;for(let o in text){let c=text[o],p=u.indexOf(c),f=" "==c?d.avgWidth:d.widths[p]+Math.ceil(d.avgWidth/4);if(null!=h&&n+f>h){if(r){n-=a;let t=text.slice(o-s);" "==t[0]&&t.split("").splice(0,1).join(""),e.splice(i+1,0,t),e[i]=e[i].split("").splice(0,o-s).join("")}else{let t="";n-=a;let r=u.indexOf("-");n+=d.widths[r]+Math.ceil(d.avgWidth/4);o-=s;for(;o<text.length;){let e=d.widths[l[i][o]]+Math.ceil(d.avgWidth/4);if(n+e>h)break;t+=text[o],n+=e,o++}t+="-",l[i].splice(o),l[i].push(r),e[i]=t,e.push(text.slice(o))}break}" "==c?(n+=f,l[i].push(-1),r=!0,a=d.avgWidth,s=0,n>g&&(g=n)):(n+=f,a+=f,-1==p&&(console.error("Oh no! The text sprite "+JSON.stringify(t.id)+" tried to use the character "+JSON.stringify(c)+". The "+(".Internal.defaultFont"==t.font?"default font":JSON.stringify(t.font))+" only supports these characters:\n"+u),Bagel.internal.oops(t.game)),l[i].push(p),s++)}n>g&&(g=n),i++}p=2*g,f=d.maxHeight*e.length*2}if(t.width=p*m,t.height=f*m,o)return l;a.width=p,a.height=f,s.fillStyle=t.color;let y=0;for(let t in e){let n=e[t],i=0;for(let e in n){let a=n[e];if(" "==a)i+=2*d.avgWidth;else{let n=l[t][e],o=d.starts[n],u=d.widths[n],g=d.heights[n],h=0,c=u*g,p=d.maxHeight/2-g/2;for(r.vars.font.top[a]&&(p=0),r.vars.font.bottom[a]&&(p=d.maxHeight-g),p+=y;h<c;)"1"==d.pixels[o]&&s.fillRect(h%u*2+i,Math.floor(2*(Math.floor(h/u)+p)),2,2),h++,o++;i+=2*(d.widths[n]+Math.ceil(d.avgWidth/4))}}y+=d.maxHeight}},prerenderNonBitmap:(e,t,n,i,r,a,s,o)=>{let l=t.internal.last;a.font=t.size+"px "+t.font;let d=1.5*a.measureText("M").width*i,u=t.wordWrapWidth,g=2*a.measureText("M").width;if(null!=u&&u<g&&(u=g),o)e=o,r.width=t.width*n,r.height=t.height*i;else{let o=0,g=0;for(;g<e.length;){let t=e[g].split(" "),n=a.measureText(" ").width,i=0,r=!1;for(let s in t){let o=a.measureText(t[s]).width;if(i+=o,null!=u&&i>u){if(i-=o,r)e.splice(g+1,0,t.slice(s).join(" ")),t.splice(s,t.length-s),e[g]=t.join(" ");else{let n,r="";for(n in i+=a.measureText("-").width,t[s]){let e=a.measureText(t[s][n]).width;if(i+e>u)break;r+=t[s][n],i+=e}r+="-",e.splice(g+1,0,t.slice(s).join(" ").slice(n)),t.splice(s,t.length-s),e[g]=t.join(" ")+r}break}r=!0,s!=t.length-1&&(i+=n)}i>o&&(o=i),g++}if(t.width=Math.round(o),t.height=Math.round(Math.ceil(d)*e.length/i),l.scaleX=n,l.scaleY=i,s)return e;r.width=o*n,r.height=t.height*i}a.font=t.size+"px "+t.font,a.fillStyle=t.color,a.textBaseline="middle",a.scale(n,i);let h=Math.ceil(d)/2;for(let t in e)a.fillText(e[t],0,(h+Math.ceil(d)*t)/i);a.setTransform(1,0,0,1,0,0)}}}},loadPlugin:(e,t,n,i)=>{let r=Bagel.internal.subFunctions.loadPlugin;e=Bagel.internal.deepClone(e);let a=Bagel.internal.current;Bagel.internal.saveCurrent(),a.plugin=e,e.args=n,e.plugin&&e.plugin.scripts&&e.plugin.scripts.preload&&e.plugin.scripts.preload(e,t,Bagel.step.plugin.scripts),(e=r.check(t,e,i)).args=Bagel.internal.deepClone(n);let s=r.merge;s.types.assets(t,e),s.types.sprites(t,e),s.methods(t,e),e.plugin.scripts.init&&e.plugin.scripts.init(e,t,Bagel.step.plugin.scripts),s.listeners(t,e),t.internal.plugins[e.info.id]=e,Bagel.internal.loadCurrent()},loadAsset:(e,t,n,i,r,a,s)=>{let o=Bagel.internal.current;Bagel.internal.saveCurrent(),o.asset=e,o.assetType=n,o.i=r,o.where=i,o.game=t;let l=t.internal.combinedPlugins.types.assets[n];if(null==l)return void console.warn("The asset type "+JSON.stringify(n)+" doesn't appear to exist for this game. You might want to check that the plugin that adds it's been loaded. In the game "+JSON.stringify(t.id)+".game.assets."+n+" item "+r+".");let d="dynamic"!=t.config.loading.mode||a||l.forcePreload&&!s,u=l.internal.plugin;o.plugin=u;let g,h=t.internal.assets;null==h.assets[n]&&(h.assets[n]={}),e=Bagel.check({ob:e,where:i,syntax:l.internal.args},Bagel.internal.checks.disableArgCheck),l.check&&(g=l.check(e,t,Bagel.internal.check,u,r)),g&&(Bagel.internal.loadCurrent(),console.error(g),console.log("In plugin "+JSON.stringify(u.info.id)+"."),Bagel.internal.oops(t));let c,p=((e,t,n)=>i=>{let r=t.internal.assets,a=t.internal.combinedPlugins,s=a.types.internal.pluralAssetTypes[a.types.assets[n].get];r.loadingIDs[s][e.id]=!1,r.assets[s][e.id]=i,r.loaded++,r.loading--,r.toLoad[s]&&r.toLoad[s][e.id]&&delete r.toLoad[s][e.id],0==r.loading&&t.config.loading.skip&&(t.loaded=!0,Bagel.internal.subFunctions.init.onload(t))})(e,t,n);if(l.set&&(c=((e,t,n,i,r,a,s)=>o=>{Bagel.internal.saveCurrent();let d=Bagel.internal.current;d.plugin=i.internal.plugin,d.pluginProxy=!0,d.game=t,d.asset=e,d.assetType=r,d.i=a,d.where=s;let u=l.set(o,e,n,t,i.internal.plugin);u&&(console.error(u),Bagel.internal.oops(t)),Bagel.internal.loadCurrent()})(e,t,p,l,n,r,i)),d){let i=t.internal.combinedPlugins,a=i.types.internal.pluralAssetTypes[i.types.assets[n].get];h.loading++,null==h.loadingIDs[a]&&(h.loadingIDs[a]={}),l.init(e,c||p,t,l.internal.plugin,r),h.loadingIDs[a][e.id]=!0}else{let a=t.internal.assets.toLoad;null==a[n]&&(a[n]={}),a[n][e.id]={ready:p,set:c,asset:e,assetLoader:l,i:r,where:i,game:t}}Bagel.internal.loadCurrent()},createSprite:(e,t,n,i,r,a)=>{let s=Bagel.internal.subFunctions.createSprite,o=t.internal.combinedPlugins;n?(e.type&&e.type!=n.type&&(console.error('Oops, clones have to have the same type as the parent. You can fix this by removing the "type" argument for this clone. If it needs to be that type, you should make a different parent for creating clones of that type.'),Bagel.internal.oops(t)),e.type=n.type):e.type=null==e.type?o.defaults.sprites.type:e.type;let l=o.types.sprites[e.type];if(null==l){let n=Object.keys(o.types.sprites);n.includes(e.type)||(e.id?console.error("Oops, you used an invalid sprite type. You tried to use "+JSON.stringify(e.type)+" for the sprite "+JSON.stringify(e.id)+". It can only be one of these:\n"+n.reduce((e,t)=>e+"  โข "+JSON.stringify(t)+" -> "+o.types.sprites[t].description+"\n","")):a?console.error("Oops, you used an invalid sprite type. You tried to use "+JSON.stringify(e.type)+" for sprite "+a+". It can only be one of these:\n"+n.reduce((e,t)=>e+"  โข "+JSON.stringify(t)+" -> "+o.types.sprites[t].description+"\n","")):console.error("Oops, you used an invalid sprite type. You tried to use "+JSON.stringify(e.type)+". It can only be one of these:\n"+n.reduce((e,t)=>e+"  โข "+JSON.stringify(t)+" -> "+o.types.sprites[t].description+"\n","")),Bagel.internal.oops(t))}let d=Bagel.internal.current,u=d.plugin?d.plugin.info.id:null;Bagel.internal.saveCurrent(),d.sprite=e,d.game=t,d.plugin=l.internal.plugin,r||(d.pluginProxy=!0,e=s.check(e,t,n,i,u),Bagel.internal.current.pluginProxy=!1),e.internal={Bagel:{scripts:{init:[],main:[],all:[]},rerunListeners:[],rerunIndex:{},rendererNotInitialized:!0,onVisibleTriggered:!1,onVisibleTriggeredBefore:!1,onInvisibleTriggered:!1,renderID:null,actingPlugin:Bagel.internal.getActingPluginId(!0)},dontClone:!0},e.cloneIDs=[],e.cloneCount=0,e.isClone=!!n,e.idIndex=a;let g=s.register;return d=Bagel.internal.current,s.extraChecks(e,t,i,a),d.pluginProxy=!0,g.scripts("init",e,t,n),g.scripts("main",e,t,n),g.scripts("all",e,t,n),g.methods(e,t),d.pluginProxy=!1,g.listeners(e,t,n),t.internal.idIndex[e.id]=a,e.debug={renderTime:0,scriptTime:0},e.game=t,(n=>{e.clone=(e=>{let t,i=n,r=i.game;null==(e=e||{}).id?(t=Bagel.internal.findCloneID(i,r),e.id=t):t=e.id,i.cloneIDs.push(t),i.cloneCount++;let a=Bagel.internal.findSpriteIndex(r);e=Bagel.internal.createSprite(e,r,i,'the function "sprite.clone"',!1,a),r.game.sprites[a]=e,Bagel.internal.current.sprite=e;for(let t in e.scripts.init)e.scripts.init[t](e,r,Bagel.step.sprite);for(let t in e.scripts.main)e.scripts.main[t](e,r,Bagel.step.sprite);return Bagel.internal.current.sprite=i,e}),e.delete=(t=>{e.internal.actingPlugin&&Bagel.internal.getActingPluginId()!=e.internal.actingPlugin&&(console.error("Sorry, you can't delete sprites created as parts of plugins as it would likely cause issues."),Bagel.internal.oops(n.game));let i=n.game,r=Bagel.internal.subFunctions.delete,a=Bagel.internal.current;Bagel.internal.saveCurrent(),a.game=i,a.sprite=e,r.event(n,i,a),a.plugin=null,r.bitmapSprite(n,i),r.scripts("init",n,i),r.scripts("main",n,i),r.scripts("all",n,i),r.misc(n,i),Bagel.internal.loadCurrent()}),e.deleteClones=(n=>{let i=[...e.cloneIDs];for(let e in i)if(i[e]){let n=t.get.sprite(i[e],!0);n&&n.delete()}})})(e),s.init(e,t,s),Bagel.internal.loadCurrent(),e},tick:e=>{Bagel.internal.current.mainLoop=!0;let t=Bagel.internal.subFunctions.tick,n=new Date;if("complete"==document.readyState){let e;Bagel.internal.frameStartTime=performance.now(),window.requestIdleCallback?requestIdleCallback(t.calculateRenderTime):setTimeout(t.calculateRenderTime,0);for(let n in Bagel.internal.games){e=performance.now();let i=Bagel.internal.games[n];Bagel.internal.current.game=i,i.config.isLoadingScreen||t.scaleCanvas(i);let r=i.internal,a=r.renderer;if(r.pluginsDone||0==r.pluginsLoading&&(Bagel.internal.subFunctions.init.onPluginsReady(i),r.pluginsDone=!0),r.pluginsDone&&(!i.config.isLoadingScreen||i.internal.mainGame.internal.pluginsDone))if(r.assets.initialized){i.state!=r.lastPrepState&&0==r.assets.loading&&(Bagel.internal.triggerPluginListener("prepState",i,i.state),0==r.assets.loading?r.lastPrepState=i.state:(i.loaded=!1,null==r.loadingScreen&&Bagel.internal.subFunctions.init.loadingScreen(i))),i.loaded?(t.loaded(i,e)&&(Bagel.internal.subFunctions.init.loadingScreen(i),t.loading(i)),"canvas"!=a.type&&(i.scriptTime=performance.now()-e)):(t.loading(i),i.scriptTime=performance.now()-e);let n=i.config.display.renderer;if("auto"!=n&&a.type!=n){if("webgl"==a.type){a.gl.getExtension("WEBGL_lose_context").loseContext();let e=a.textureSlots;for(let t in e)e[t].gl&&e[t].gl.getExtension("WEBGL_lose_context").loseContext()}a.type=n,console.error("Renderers currently can't be switched for active games.")}}else r.loadingScreen&&!r.loadingScreen.loaded||Bagel.internal.subFunctions.init.assets(i);let s=performance.now();i.internal.FPSFrames++,s-i.internal.lastFPSUpdate>=1e3&&(i.currentFPS=i.internal.FPSFrames,i.internal.FPSFrames=0,i.internal.lastFPSUpdate=s);let o=i.input.touchScrollMomentum;i.input.scrollDelta.x=o.x,i.input.scrollDelta.y=o.y;let l=i.config.input.touch.scroll.momentum;o.x*=l,o.y*=l,i.input.scrollDelta.z=0}}Bagel.internal.resetCurrent();new Date;t.tick()},subFunctions:{init:{check:e=>(null==e&&(console.log("Hmm, looks like you forgot the first argument for this function: the game JSON. It should be an object."),Bagel.internal.oops()),"object"!=typeof e&&(console.error("Oh no! Your game JSON seems to be the wrong type. It must be an object but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."),Bagel.internal.oops()),null==e.id&&(console.error("Oh no! You forgot to specifiy an id for the game."),Bagel.internal.oops()),e.internal={renderer:{bitmapIndexes:[],bitmapCount:0,queue:{bitmap:{new:[],delete:{},layer:[]},texturemapsUpdated:{}},queueLengths:{add:0,delete:0},locations:{},buffers:{},vertices:new Float32Array,textureCoordinates:new Float32Array,bitmapSpriteData:[],colorCanvas:null,colorCtx:null,lastBackgroundColor:null,verticesUpdated:!1,displayedDownscaleWarning:!1,activeGLTextureContexts:[],glTextureContexts:0,textures:{},textureSlots:[],textureSlotsUsed:0,bitmapsUsingTextures:{},maxTextureSlots:null,tintedTextures:{},tintedTextureCounts:{},downscaled:{},animatedIntoCombined:{},loadingScreenTextures:{},loadingScreenBitmaps:{},scaledBitmaps:[],layers:[],width:e.width,height:e.height,scaleX:1,scaleY:1,renderWidth:null,renderHeight:null,lastRender:new Date,canvas:document.createElement("canvas"),ratio:e.width/e.height},ids:[],idIndex:{},FPSFrames:0,lastFPSUpdate:performance.now(),scripts:{index:{init:{},main:{},all:[],sprites:{init:{},main:{},all:[]}}},assets:{loading:0,loaded:0,assets:{},toLoad:{},loadingIDs:{},ranTasks:!1,initialized:!1,assetsLoading:0},combinedPlugins:{types:{internal:{pluralAssetTypes:{}}},methods:{bagel:{},game:{},sprite:{}},defaults:{sprites:{type:"sprite"}},listeners:{}},input:{pendingTouchScrollMomentum:{x:0,y:0},processTouches:(e,t)=>{let n,i,r=t.internal.renderer,a=r.canvas.getBoundingClientRect(),s=t.input.mouse,o=t.input,l=[...e.touches].find(e=>0==e.identifier),d=e.touches[e.touches.length-1],u=l||d;if(u){let e=(u.clientX-a.left)/r.styleWidth*t.width,d=(u.clientY-a.top)/r.styleHeight*t.height;l?(n=e-s.x,i=d-s.y):o.touch.dragging=!1,s.x=e,s.y=d,o.mouse.down=!0,o.touch.down=!0}else o.touch.dragging=!1,o.mouse.down=!1,o.touch.down=!1;let g=o.touch.touches;o.touch.touches=[];let h=0;for(;h<e.touches.length;){let n=e.touches[h],i={x:(n.clientX-a.left)/r.styleWidth*t.width,y:(n.clientY-a.top)/r.styleHeight*t.height},s=g.find(e=>e.id==n.identifier);s=s?s.origin:i,o.touch.touches.push({x:i.x,y:i.y,id:n.identifier,origin:s}),h++}return[n,i]}},lastState:!e.state,lastPrepState:!e.state,plugins:{},pluginsLoading:0,pluginsDone:!1,dontClone:!0},e=Bagel.check({ob:e,where:"Game",syntax:Bagel.internal.checks.game},Bagel.internal.checks.disableArgCheck)),listeners:(e,t,n)=>{(e=>{e.input={touch:{down:!1,dragging:!1,touches:[]},mouse:{down:!1,dragging:!1,x:e.width/2,y:e.height/2},keys:{keys:{},keyCodes:{}},scrollDelta:{x:0,y:0,z:0},touchScrollMomentum:{x:0,y:0}},e.input.keys.isDown=(t=>!!e.input.keys.keys[t]),e.input.keys.isCodeDown=(t=>!!e.input.keys.keyCodes[t]),"complete"==document.readyState?Bagel.internal.subFunctions.init.documentReady(e):document.addEventListener("readystatechange",t=>{"complete"==document.readyState&&Bagel.internal.subFunctions.init.documentReady(e)}),t.addEventListener("wheel",t=>{let n=e.config.input.mouse.scrollSensitivity;e.input.scrollDelta.x+=t.deltaX*n,e.input.scrollDelta.y+=t.deltaY*n,e.input.scrollDelta.z+=t.deltaZ*n,t.preventDefault()},!0),t.addEventListener("mousemove",t=>{let n=e.internal.renderer,i=n.canvas.getBoundingClientRect(),r=e.input.mouse;r.x=(t.clientX-i.left)/n.styleWidth*e.width,r.y=(t.clientY-i.top)/n.styleHeight*e.height},!1),t.addEventListener("mousedown",t=>{Bagel.device.is.touchscreen=!1;let n=e.input.mouse;switch(t.which){case 1:n.down=!0;break;case 2:n.middleDown=!0;break;case 3:n.rightDown=!0}Bagel.internal.inputAction.input()},!1),t.addEventListener("mouseup",t=>{let n=e.input.mouse;switch(t.which){case 1:n.down=!1;break;case 2:n.middleDown=!1;break;case 3:n.rightDown=!1}Bagel.internal.inputAction.input()},!1),t.addEventListener("touchstart",t=>{Bagel.device.is.touchscreen=!0,e.internal.input.processTouches(t,e),t.cancelable&&t.preventDefault(),Bagel.internal.inputAction.input()},!1),t.addEventListener("touchmove",t=>{let n=e.input;Bagel.device.is.touchscreen=!0;let i=e.internal.input.processTouches(t,e),[r,a]=i,s=n.touch.touches.find(e=>0==e.id),o=e.internal.input.pendingTouchScrollMomentum;if(o.x=0,o.y=0,s){let t=e.config.input.touch.scroll.deadzone;Math.abs(s.x-s.origin.x)>t&&(n.scrollDelta.x-=r,o.x=-r/1.5,n.touch.dragging=!0),Math.abs(s.y-s.origin.y)>t&&(n.scrollDelta.y-=a,o.y=-a/1.5,n.touch.dragging=!0)}t.cancelable&&t.preventDefault()},!1),t.addEventListener("touchend",t=>{let n=e.input;Bagel.device.is.touchscreen=!0,e.internal.input.processTouches(t,e);let i=e.internal.input.pendingTouchScrollMomentum;n.touchScrollMomentum.x=i.x,n.touchScrollMomentum.y=i.y,t.cancelable&&t.preventDefault(),Bagel.internal.inputAction.input()},!1),t.addEventListener("contextmenu",e=>e.preventDefault()),n||(document.addEventListener("keydown",e=>{for(let t in Bagel.internal.games){let n=Bagel.internal.games[t];n.input.keys.keys[e.key]=!0,n.input.keys.keyCodes[e.keyCode]=!0}},!1),document.addEventListener("keyup",e=>{for(let t in Bagel.internal.games){let n=Bagel.internal.games[t];n.input.keys.keys[e.key]=!1,n.input.keys.keyCodes[e.keyCode]=!1}},!1))})(e)},basicRendererInit:e=>{let t=e.config;if(!t.isLoadingScreen){let n=e.internal.renderer,i=document.createElement("canvas");i.width=1,i.height=1,n.blankTexture=i;let r,a=Bagel.internal.subFunctions.init,s={antialias:t.display.antialiasing,powerPreference:"high-performance",depth:!1,preserveDrawingBuffer:!0,failIfMajorPerformanceCaveat:!0},o=n.canvas;if("auto"==t.display.renderer){r=o.getContext("webgl",s)||o.getContext("experimental-webgl",s);let i=Bagel.device.webgl;if(r){t.display.renderer="webgl",a.findRendererLimits(e,n,r);let s=t.display.webgl.minimumLimits;(i.textureSizeLimit<s.textureSize||i.textureCountLimit<s.textureCount)&&(t.display.renderer="canvas",r.getExtension("WEBGL_lose_context").loseContext(),r=null)}else t.display.renderer="canvas",a.findRendererLimits(e,n)}else a.findRendererLimits(e,n,r);if(n.type=t.display.renderer,"webgl"==n.type)if(r||(r=n.canvas.getContext("webgl",s)||n.canvas.getContext("experimental-webgl",s)),n.gl=r,r){a.findRendererLimits(e,n,r),r.viewport(0,0,n.canvas.width,n.canvas.height);let t=Bagel.device.webgl;null==t.supported&&(r?(t.supported=!0,Bagel.device.is.webGLSupported=!0,t.textureCountLimit=r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),t.textureSizeLimit=r.getParameter(r.MAX_TEXTURE_SIZE)):(t.supported=!1,Bagel.device.is.webGLSupported=!1));let i=e.config.display.webgl.minimumLimits;(t.textureSizeLimit<i.textureSize||t.textureCountLimit<i.textureCount)&&a.errorScreen(e,0),n.colorCanvas=document.createElement("canvas"),n.colorCanvas.width=1,n.colorCanvas.height=1,n.colorCtx=n.colorCanvas.getContext("2d")}else a.errorScreen(e,0),n.type="canvas";Bagel.internal.subFunctions.tick.scaleCanvas(e)}},misc:e=>{e.loaded=!1,e.paused=!1,e.error=!1,e.currentFPS=60,e.maxPossibleFPS=60,e.frameTime=0,e.scriptTime=0,e.renderTime=0;let t=e.internal.renderer;t.canvas.id="Bagel.js "+e.id,t.canvas.width=e.width,t.canvas.height=e.height,e.config.display.mode,t.canvas.style="display: block; touch-action: none; user-select: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);",(e=>{e.add={sprite:(t,n="the function Game.add.sprite")=>{n+=" -> the first argument";let i=Bagel.internal.findSpriteIndex(e);if(t=Bagel.internal.createSprite(t,e,!1,n,!1,i),e.game.sprites[i]=t,e.state==e.internal.lastState){let n=Bagel.internal.current;Bagel.internal.saveCurrent(),n.sprite=t,n.game=e;for(let n in t.scripts.init){let i=t.scripts.init[n];i.stateToRun==e.state&&"function"==typeof i.code&&i.code(t,e,Bagel.step.sprite)}Bagel.internal.loadCurrent()}let r=Bagel.internal.current;Bagel.internal.saveCurrent(),r.sprite=t,r.game=e;for(let n in t.scripts.main){let i=t.scripts.main[n];i.stateToRun==e.internal.lastState&&"function"==typeof i.code&&i.code(t,e,Bagel.step.sprite)}return Bagel.internal.loadCurrent(),t},asset:{}},e.get={asset:{},sprite:(t,n)=>Bagel.get.sprite(t,e,n)},e.set={asset:{}},e.delete=(t=>{e.config.display.dom&&(null==e.config.display.htmlElementID&&"fill"==e.config.display.mode?e.internal.renderer.canvas.parentElement.remove():e.internal.renderer.canvas.remove());let n=e.internal.renderer;if(e.config.isLoadingScreen){let t=n.loadingScreenBitmaps;for(let n in t)t[n]&&Bagel.internal.render.bitmapSprite.delete(n,e);let i=n.loadingScreenTextures;for(let t in i)i[t]&&Bagel.internal.render.texture.delete(t,e,!0,!1,!0)}if("webgl"==n.type&&!e.config.isLoadingScreen){e.internal.renderer.gl.getExtension("WEBGL_lose_context").loseContext();let t=e.internal.renderer.textureSlots;for(let e in t)t[e].gl&&t[e].gl.getExtension("WEBGL_lose_context").loseContext()}delete Bagel.internal.games[e.id]})})(e)},bundledAssets:e=>{Bagel.internal.saveCurrent(),Bagel.internal.current.plugin=e.internal.plugins.Internal,e.set.asset.font(".Internal.defaultFont",{widths:[4,4,4,4,4,4,4,4,3,4,4,4,5,4,5,3,5,4,4,3,4,3,5,5,3,4,3,3,3,3,3,3,3,3,3,3,3,1,5,5,5,3,5,3,2,2,3,3,4,3,1,2,1,3,2,2,5,5,3,3,4,1,2,2,2,2],heights:[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,5,2,6,3,5,5,3,1,1,3,5,5,2,2,2,2,5,5,5,5,2,5,5,5,5,5],pixels:"011010011111100110011110100111101001111001111000100010000111111010011001100111101111100011101000111111111000111010001000111010001011100111111001100111111001100111101001001011101110001000110010110100110101100101010011000100010001000111110001110111010110001100011001110110111001100101110100011000110001011101111011111001000111010001100011001001101111010011110100110010111100001100001111011101001001001010011001100110010110101101101101010100011000110001101011101110001010100010001010100011011011010100101111000100100100111101010110110101011001001001011111100101010011111000101000111010110111100100111110011100111111110011110111111100101001001011110111110111111110111100100111100101100001011101011100100111100010001111000100011111010001110001011111000100100010001000100010001000101010100100010100110010101100100110110101010101101010011001010110010111010111111111100011110001100000011011101101111101100000100010001000100010000100000100000100000100000110001000101010000101010001000101011010111111110101011110101011111100110111101100111"}),Bagel.internal.loadCurrent()},scripts:(e,t)=>{let n=e.game.scripts[t],i=e.internal.scripts.index[t];for(let e in n){let r=n[e];if("all"==t)i.push({script:e});else{let t=r.stateToRun;null==i[t]&&(i[t]=[]),i[t].push({script:e})}}},initScripts:e=>{let t=Bagel.internal.subFunctions.init.scripts;t(e,"init"),t(e,"main"),t(e,"all")},plugins:e=>{for(let t in e.game.plugins){let n=e.game.plugins[t];e.internal.pluginsLoading++,((e,t,n,i)=>{fetch(t).then(r=>{r.ok?r.text().then(r=>{e.internal.pluginsLoading--,"object"!=typeof(r=new Function("game","return "+r)(e))&&(console.error("Erm, the plugin with the src "+JSON.stringify(t)+" isn't an object, it's "+Bagel.internal.an(Bagel.internal.getTypeOf(r))),Bagel.internal.oops(e)),Bagel.internal.loadPlugin(r,e,n,i)}):(console.error("Huh, the network request for a plugin failed. This could be because the server can't be accessed or the src is incorrect. Check out the HTTP error above for more info."),Bagel.internal.oops(e))})})(e,n.src,n.args?Bagel.internal.deepClone(n.args):{},t)}},assets:(e,t)=>{e.internal.assets.initialized=!0;let n=e.game.assets;for(let i in n){let r=n[i];for(let n in r){let a=r[n];Bagel.internal.loadAsset(a,e,i,"Game.game.assets."+i+" item "+n,n,!1,t)}}0==e.internal.assets.loading&&(e=>{e.loaded=!0,Bagel.internal.subFunctions.init.deleteLoadingScreen(e),setTimeout(t=>{e.loaded&&Bagel.internal.subFunctions.init.onload(e)},0)})(e)},preloadTasks:e=>{let t=e.internal.assets;t.assetsLoading=t.loading;let n=e.game.scripts.preload;t.loading+=n.tasks.length,n.misc&&t.loading++},methods:e=>{let t=e.internal.combinedPlugins.methods.game;for(let n in t){let i=t[n];Bagel.internal.subFunctions.init.subMethods(e,i,n,e)}},subMethods:(e,t,n,i)=>{let r=!0;if(t.internal&&t.internal.isNotCategory&&(r=!1),r){i[n]||(i[n]={});for(let r in t)Bagel.internal.subFunctions.init.subMethods(e,t[r],r,i[n])}else{let r=!0;i.hasOwnProperty(n)&&(t.fn.overwrite||(r=!1,console.warn("Oops. We've got a conflict. Plugin "+JSON.stringify(t.internal.plugin.info.id)+" tried to overwrite the "+JSON.stringify(n)+" property in the game "+JSON.stringify(e.id)+' without having the correct tag. The overwrite has been blocked.\nIf you want to overwrite the older type definition, add this to the function JSON: "overwrite: true".'))),r&&((e,t,n,i)=>{e.fn.normal?i[n]=e.fn.fn:e.fn.obArg?i[n]=(i=>{null==i&&(console.error("Oops, this function takes one argument: an object. You didn't give any arguments."),Bagel.internal.oops(t)),"object"!=Bagel.internal.getTypeOf(i)&&(console.error("Huh, looks like you used "+Bagel.internal.an(Bagel.internal.getTypeOf(i))+" instead of an object."),Bagel.internal.oops(t)),Bagel.internal.saveCurrent(),current.game=t,current.plugin=e.internal.plugin,i=Bagel.check({ob:i,syntax:e.fn.args,where:"game "+JSON.stringify(t.id)+"'s "+JSON.stringify(n)+" method"},Bagel.internal.checks.disableArgCheck);let r=e.fn.fn(t,i,current.plugin);return Bagel.internal.loadCurrent(),r}):i[n]=((...i)=>{let r=Object.keys(e.fn.args),a={};for(let e in i)null==r[e]&&(r[e]="Your "+Bagel.internal.th(parseInt(e))+" argument"),a[r[e]]=i[e];let s=Bagel.internal.current;Bagel.internal.saveCurrent(),s.game=t,s.plugin=e.internal.plugin,a=Bagel.check({ob:a,syntax:e.fn.args,where:"game "+JSON.stringify(t.id)+"'s "+JSON.stringify(n)+" method"},Bagel.internal.checks.disableArgCheck,!1,"Btw, the arguments go in this order: "+r.join(", ")+".");let o=e.fn.fn(t,a,e.internal.plugin);return Bagel.internal.loadCurrent(),o})})(t,e,n,i)}},initSprites:e=>{for(let t in e.game.sprites)Bagel.internal.createSprite(e.game.sprites[t],e,!1,"Game.game.sprites item "+t,!1,parseInt(t))},loadingScreen:e=>{if(!e.config.loading.skip){Bagel.internal.saveCurrent(),Bagel.internal.current.plugin=e.internal.plugins.Internal;let t,n=Bagel.internal.deepClone(e.config.loading.animation),i="full";n.config&&n.config.display&&null!=n.config.display.resolution&&(i=n.config.display.resolution),n.id=".Internal.loadingScreen."+e.id,n.width=e.width,n.height=e.height,t="transparent"==e.config.display.backgroundColor?document.body.bgColor:e.config.display.backgroundColor,n.config={loading:{skip:!0,mode:"preload"},display:{backgroundColor:t,dom:!1,renderer:e.internal.renderer.type},disableBagelJSMessage:!0,isLoadingScreen:!0},e.internal.resolutionModeWas=e.config.display.resolution,e.config.display.resolution=i,null==n.vars&&(n.vars={}),n.vars.loading={progress:0,loaded:0,loading:e.internal.assets.loading,done:!1,game:e},n=Bagel.init(n),e.internal.loadingScreen=n,n.internal.mainGame=e,n.internal.renderer=e.internal.renderer,e.internal.pluginsDone&&Bagel.internal.subFunctions.init.rendererInit(e),Bagel.internal.loadCurrent()}},deleteLoadingScreen:e=>{e.internal.loadingScreen&&(e.internal.loadingScreen.delete(),delete e.internal.loadingScreen,e.config.display.resolution=e.internal.resolutionModeWas)},errorScreen:(e,t)=>{e.config.loading.animation=Bagel.internal.errorGameObject,e.internal.assets.loading++,e.loaded=!1,e.config.loading.skip=!1,e.internal.errorCode=t},documentReady:e=>{if(e.config.display.dom)if(e.config.display.htmlElementID)document.getElementById(e.config.display.htmlElementID).appendChild(e.internal.renderer.canvas);else if(null==document.body&&(document.body=document.createElement("body")),"fill"==e.config.display.mode){let t=document.createElement("p");t.style="position: absolute;top:0;bottom:0;left:0;right:0;margin:auto;",t.appendChild(e.internal.renderer.canvas),document.body.appendChild(t)}else document.body.appendChild(e.internal.renderer.canvas);Bagel.internal.subFunctions.init.plugins(e)},onload:e=>{if(!e.internal.pluginsDone)return void(e=>{setTimeout(t=>{Bagel.internal.subFunctions.init.onload(e)},0)})(e);let t=e.game.sprites;for(let n in t)null!=t[n]&&Bagel.internal.subFunctions.createSprite.triggerListeners(t[n],e)},rendererInit:e=>{if(e.config.isLoadingScreen)return;let t=e.internal.renderer.type,n=Bagel.internal.subFunctions.tick.render;n[t].init&&n[t].init(e);let i=new Image;(e=>{i.onload=(t=>{Bagel.internal.render.texture.get(".Internal.missing",e)||Bagel.internal.render.texture.new(".Internal.missing",i,e,!1,"static")})})(e),i.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAF0lEQVQYVwXBAQEAAACCIPo/2mAoWWrmOPoF/8JfnIkAAAAASUVORK5CYII="},findRendererLimits:(e,t,n)=>{let i=Bagel.device.webgl,r=!1;n&&(r=!0,i.textureCountLimit=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),i.textureSizeLimit=n.getParameter(n.MAX_TEXTURE_SIZE),i.viewportSizeLimit=Math.min(...n.getParameter(n.MAX_VIEWPORT_DIMS))),null!=n&&(i.supported=r,Bagel.device.is.webGLSupported=r)},onPluginsReady:e=>{let t=Bagel.internal.subFunctions.init;t.methods(e),e.internal.loadingScreen&&!e.internal.loadingScreen.loaded||t.assets(e),t.rendererInit(e),t.preloadTasks(e),t.initScripts(e),t.initSprites(e)}},loadPlugin:{check:(e,t,n)=>{let i=Bagel.internal.current;return Bagel.internal.saveCurrent(),i.plugin=t,i.game=e,(t=Bagel.check({ob:t,syntax:Bagel.internal.checks.plugin,where:t.info&&t.info.id?"plugin "+t.info.id:"Game.game.plugins item "+n},Bagel.internal.checks.disableArgCheck)).internal={dontClone:!0},Bagel.internal.loadCurrent(),t},merge:{types:{assets:(e,t)=>{let n=t.plugin.types.assets,i=e.internal.combinedPlugins;for(let r in n){let a=n[r];null==i.types.assets&&(i.types.assets={});let s=!1;null!=i.types.assets[r]?a.overwrite?s=!0:console.warn("Oops. We've got a conflict. Plugin "+JSON.stringify(t.info.id)+" tried to overwrite the "+JSON.stringify(r)+' asset type without having the correct tag. The overwrite has been blocked.\nIf you want to overwrite the older type definition, add this to the new type JSON: "overwrite: true".'):s=!0,s&&(i.types.assets[r]=a,i.types.assets[r].internal={plugin:t,args:{...Bagel.internal.checks.assets,...a.args}},i.types.internal.pluralAssetTypes[a.get]=r,((t,n,i,r)=>{Bagel.get.asset[i.get]=((e,a,s)=>{let o=Bagel.internal.current,l=n.internal.combinedPlugins.types.internal.pluralAssetTypes[i.get];null==(a=null==a?o.game:a)&&(console.error("Oops. Looks like you're trying to run this function outside of a script. Try moving it and trying again. Alternatively, you can pass the game object in as the second argument to this function to fix this issue."),Bagel.internal.oops()),null==e&&(console.error('Huh, looks like you forgot the "id" argument (the first argument). That\'s the id for the asset you want to get.'),Bagel.internal.oops(a)),Bagel.internal.saveCurrent(),o.assetType=t,o.assetTypeName=i.get,o.game=a,o.plugin=r;let d=a.internal.assets,u=d.assets[t],g=!0;if(u&&u[e]&&(g=!1),g){let t=d.toLoad[l];if(t&&(t=t[e]),!t&&d.loadingIDs[l]&&d.loadingIDs[l][e])return Bagel.internal.loadCurrent(),!0;if(t){let n=t;return o.i=n.i,o.where=n.where,n.assetLoader.init({...n.asset},n.set?n.set:n.ready,n.game,n.assetLoader.internal.plugin,n.i),n.game.internal.assets.loading++,null==d.loadingIDs[l]&&(d.loadingIDs[l]={}),d.loadingIDs[l][n.asset.id]=!0,d.toLoad[l]&&d.toLoad[l][e]&&delete d.toLoad[l][e],Bagel.internal.loadCurrent(),!0}if(Bagel.internal.loadCurrent(),s)return!1;console.error("Oops. That "+i.get+" doesn't exist. You tried to get "+Bagel.internal.an(i.get)+" asset with the id "+JSON.stringify(e)+"."),Bagel.internal.oops(n)}let h=u[e];return Bagel.internal.loadCurrent(),h}),i.set&&(Bagel.set.asset[i.get]=((e,a,s)=>{let o=Bagel.internal.current,l=n.internal.combinedPlugins.types.internal.pluralAssetTypes[i.get];null==(s=null==s?o.game:s)&&(console.error("Oops. Looks like you're trying to run this function outside of a script. Try moving it and trying again. Alternatively, you can pass the game object in as the third argument to this function to fix this issue."),Bagel.internal.oops()),null==e&&(console.error('Huh, looks like you forgot the "id" argument (the first argument). That\'s the id for the asset you want to set.'),Bagel.internal.oops(s)),Bagel.internal.saveCurrent(),o.assetType=t,o.assetTypeName=i.get,o.game=s,o.plugin=r,o.asset=i,o.pluginProxy=!0;let d=e.split(".")[1],u=Bagel.internal.getActingPluginId();"."==e[0]&&(null==u?(console.error("This is awkward... IDs starting with a dot are only for plugins. You tried to set "+Bagel.internal.an(i.get)+" using the id "+JSON.stringify(e)+". If it's important that it has this name, you could write a plugin instead, just make sure its id is set to "+JSON.stringify(d)+" ;)"),Bagel.internal.oops()):d!=u&&(console.error("Erm... the only reserved prefix you can use in this plugin is "+JSON.stringify("."+u)+" and you tried to use the id "+JSON.stringify(a)+'In Game.id.\nYou can fix this by changing the prefix, removing it or changing the plugin id in "Plugin.info.id".'),Bagel.internal.oops()));let g=((e,t,n,i)=>r=>{let a=t.internal.assets;t.internal.combinedPlugins;null==a.assets[i]&&(a.assets[i]={}),a.assets[n][e]=r})(e,s,l,t),h=i.set(a,{id:e,src:null},g,s,r);h&&(console.error(h),Bagel.internal.oops(s)),Bagel.internal.loadCurrent()})),n.get.asset[i.get]=((e,t)=>Bagel.get.asset[i.get](e,n,t)),i.set&&(n.set.asset[i.get]=((e,t)=>Bagel.set.asset[i.get](e,t,n))),n.add.asset[i.get]=((t,r)=>{null==t&&(console.error('Oops, looks like you forgot the "asset" argument (the first argument). That\'s the arguments for the asset as an object.'),Bagel.internal.oops(e)),"object"!=typeof t&&(console.error('Huh, looks like you used the wrong type for the "asset" argument (the first argument). That\'s the arguments for the asset as an object. You tried to use '+JSON.stringify(t)+"."),Bagel.internal.oops(e)),r||(r="the function Game.add.asset."+i.get);let a=e.internal.combinedPlugins.types.internal.pluralAssetTypes[i.get];Bagel.internal.loadAsset(t,n,a,r,!0)})})(r,e,a,t))}},sprites:(e,t)=>{let n=t.plugin.types.sprites,i=e.internal.combinedPlugins;for(let e in n){let r=n[e];null==i.types.sprites&&(i.types.sprites={});let a=!1;if(null!=i.types.sprites[e]?r.overwrite?a=!0:console.warn("Oops. We've got a conflict. Plugin "+JSON.stringify(t.info.id)+" tried to overwrite the "+JSON.stringify(e)+' sprite type without having the correct tag. The overwrite has been blocked.\nIf you want to overwrite the older type definition, add this to the new type JSON: "overwrite: true".'):a=!0,a){let n={...Bagel.internal.checks.sprite.clones.syntax};if(r.cloneArgs){for(let e in r.cloneArgs)n[e]=r.cloneArgs[e].syntax;r.cloneArgs={...r.cloneArgs,...Bagel.internal.checks.sprite.clones.args}}r.args={...r.args,...Bagel.internal.checks.sprite.sprite},(e=>{e.listeners.property={...e.listeners.property,visible:{set:(t,n,i,r,a,s,o,l)=>{let d=Bagel.internal.render.bitmapSprite;if(n){if(e.render.onVisible){if(s.internal.Bagel.rendererNotInitialized)return".rerun";s.internal.Bagel.onVisibleTriggered||(Bagel.internal.processSpriteRenderOutput(s,e.render.onVisible(s,d.new,r,a)),s.internal.Bagel.onVisibleTriggered=!0,s.internal.Bagel.onVisibleTriggeredBefore=!0,s.internal.Bagel.onInvisibleTriggered=!1)}}else if(!l&&e.render.onInvisible){if(!s.internal.Bagel.onVisibleTriggeredBefore)return".rerun";s.internal.Bagel.onInvisibleTriggered||(Bagel.internal.processSpriteRenderOutput(s,e.render.onInvisible(s,d.delete,r,a)),s.internal.Bagel.onVisibleTriggered=!1,s.internal.Bagel.onInvisibleTriggered=!0)}}}}})(r),r.internal={plugin:t,cloneSyntax:n},i.types.sprites[e]=r}}}},method:(e,t,n,i,r,a,s,o,l)=>{let d=!1;null==r[s]?d=!0:a.overwrite?d=!0:i?console.warn("Oops. We've got a conflict. Plugin "+JSON.stringify(t.info.id)+" tried to overwrite the "+JSON.stringify(s)+" method for the "+i+' type without having the correct tag. The overwrite has been blocked.\nIf you want to overwrite the older method, add this to the method JSON: "overwrite: true".'):console.warn("Oops. We've got a conflict. Plugin "+JSON.stringify(t.info.id)+" tried to overwrite the "+JSON.stringify(s)+" "+n+' method without having the correct tag. The overwrite has been blocked.\nIf you want to overwrite the older method, add this to the method JSON: "overwrite: true".'),d&&(a.internal={plugin:t,isNotCategory:!0},"bagel"==n?a.fn.normal?o[s]=a.fn.fn:((e,t,n,i,r)=>{i.fn.obArg?o[t]=(e=>{null==e&&(e={}),"object"!=Bagel.internal.getTypeOf(e)&&(console.error("Huh, looks like you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+" instead of an object."),Bagel.internal.oops()),e=Bagel.check({ob:e,syntax:i.fn.args,where:"the Bagel.js method "+JSON.stringify(r+"."+t)},Bagel.internal.checks.disableArgCheck);let n=Bagel.internal.current;Bagel.internal.saveCurrent(),n.plugin=i.internal.plugin;let a=i.fn.fn(e,n.plugin);return Bagel.internal.loadCurrent(),a}):o[t]=((...e)=>{let n=Object.keys(i.fn.args),a={};for(let t in e)null==n[t]&&(n[t]="Your "+Bagel.internal.th(parseInt(t))+" argument"),a[n[t]]=e[t];a=Bagel.check({ob:a,syntax:i.fn.args,where:"the Bagel.js method "+JSON.stringify(r+"."+t)},Bagel.internal.checks.disableArgCheck,!1,"Btw, the arguments go in this order: "+n.join(", ")+".");let s=Bagel.internal.current;Bagel.internal.saveCurrent(),s.plugin=i.internal.plugin;let o=i.fn.fn(a,s.plugin);return Bagel.internal.loadCurrent(),o})})(0,s,0,a,l):r[s]=a)},subMethods:(e,t,n,r,a,s,o,l,d,u)=>{let g=Bagel.internal.subFunctions.loadPlugin.merge;if(r.category){let i=s;"bagel"==n?(d[a]||(d[a]={}),d=d[a],""!=u&&(u+="."),u+=a):"sprite"!=n&&(s[a]||(s[a]={}),s=s[a],""!=u&&(u+="."),u+=a),l.push(a);for(let a in r.category)g.subMethods(e,t,n,r.category[a],a,s,i,l,d,u)}else if("sprite"==n){for(let i in r.fn.appliesTo){let o=s,u=r.fn.appliesTo[i];null==s[u]&&(s[u]={}),s=s[u];for(let e in l){let t=l[e];null==s[t]&&(s[t]={}),s=s[t]}g.method(e,t,n,u,s,r,a,d),s=o}if(r.apply){null==o[r.apply.from]&&(console.error("Oops, Bagel.js can't copy that method from the sprite type "+JSON.stringify(r.apply.from)+" because it doesn't seem to exist. Check the plugin that adds it has been loaded first. Also check the names and categories. In plugin "+t.info.id+"."),Bagel.internal.oops(e));let u=o[r.apply.from][a];for(i in r.apply.to){let o=s,h=r.apply.to[i];null==s[h]&&(s[h]={}),s=s[h];for(let e in l){let t=l[e];null==s[t]&&(s[t]={}),s=s[t]}g.method(e,t,n,h,s,u,a,d),s=o}}}else g.method(e,t,n,null,s,r,a,d,u)},methods:(e,t)=>{let n=e.internal.combinedPlugins,i=["bagel","game","sprite"];for(let r in i){let a=i[r],s=t.plugin.methods[a];for(let i in s){let r=s[i],o=n.methods[a];Bagel.internal.subFunctions.loadPlugin.merge.subMethods(e,t,a,r,i,o,o,[],Bagel,"")}}},listeners:(e,t)=>{let n=e.internal.combinedPlugins.listeners,i=t.plugin.listeners;for(let e in i){let r=i[e];r&&(null==n[e]&&(n[e]=[]),n[e].push({fn:r,plugin:t}))}}}},createSprite:{check:(e,t,n,i,r)=>{let a=t.internal.combinedPlugins.types.sprites[e.type];if(n){null==a.cloneArgs&&(console.error("Oops, the sprite type "+JSON.stringify(n.type)+" doesn't support clones."),Bagel.internal.oops(t)),e=Bagel.check({ob:e,where:i,syntax:a.internal.cloneSyntax},{args:!0,missing:!0});let r=Bagel.internal.deepClone;for(let t in a.cloneArgs){let i=a.cloneArgs[t];if("replace"==i.mode)e.hasOwnProperty(t)||(n.clones.hasOwnProperty(t)?e[t]=r(n.clones[t]):n.hasOwnProperty(t)&&(e[t]=r(n[t])));else if("merge"==i.mode){if(!(n.hasOwnProperty(t)||n.clones.hasOwnProperty(t)||e.hasOwnProperty(t))){i.syntax.hasOwnProperty("default")&&(e[t]=i.syntax.default);continue}e[t]=Object.assign(r(n[t]),r(n.clones[t]),r(e[t]))}else"ignore"==i.mode&&(e.hasOwnProperty(t)||(n.clones.hasOwnProperty(t)?e[t]=r(n.clones[t]):i.syntax.hasOwnProperty("default")&&(e[t]=i.syntax.default)))}if(n&&(e.cloneID=n.cloneIDs.length-1,e.parent=n),a.check){let n=a.check(e,t,Bagel.check,i);n&&(console.error(n),Bagel.internal.oops(t))}return e}let s=Bagel.internal.current;return Bagel.internal.saveCurrent(),s.sprite=e,s.game=t,e=Bagel.check({ob:e,where:i,syntax:n?a.internal.cloneSyntax:a.args},Bagel.internal.checks.disableArgCheck),Bagel.internal.loadCurrent(),e},extraChecks:(e,t,n,i)=>{let r=t.internal.combinedPlugins.types.sprites[e.type];if(null==r.check)return;let a=Bagel.internal.current,s=r.check(e,t,Bagel.check,a.plugin,i,n);s&&(console.error(s),console.log("In "+n),Bagel.internal.oops(t))},init:(e,t,n)=>{let i=Bagel.internal.current;Bagel.internal.saveCurrent(),i.sprite=e,i.game=t;let r=t.internal.combinedPlugins.types.sprites[e.type],a=r.internal.plugin;i.plugin=a,r.init&&r.init(e,t,i.plugin),t.loaded&&t.internal.pluginsDone&&(n.triggerListeners(e,t),Bagel.internal.processSprite(e)),Bagel.internal.loadCurrent()},triggerListeners:(e,t)=>{let n=t.internal.combinedPlugins.types.sprites[e.type];n.internal.plugin;if(t.error)return;let i=!0;if(n.listeners.trigger){for(let r in n.listeners.property)if(e.internal.Bagel.properties.hasOwnProperty(r)){let n=Bagel.internal.triggerSpriteListener("set",r,e,t,!0);"visible"!=r&&n&&(i=!1)}}else Bagel.internal.triggerSpriteListener("set","visible",e,t,!0);e.internal.Bagel.rendererNotInitialized&&i&&(e.internal.Bagel.rendererNotInitialized=!1,Bagel.internal.subFunctions.createSprite.initRender(e,t))},register:{scripts:(e,t,n,i)=>{let r,a=t.scripts[e],s=n.internal.scripts.index.sprites[e];for(let o in a)r=i?n.state:"all"==e?null:a[o].stateToRun,"all"==e?(s.push({script:o,sprite:t,isClone:t.isClone}),t.internal.Bagel.scripts[e].push({id:s.length-1})):(null==s[r]&&(s[r]=[]),s[r].push({script:o,sprite:t,isClone:t.isClone}),t.internal.Bagel.scripts[e].push({id:s[r].length-1,state:r}))},subMethods:(e,t,n,i,r)=>{let a=!0;if(e.internal&&e.internal.isNotCategory&&(a=!1),a){i[t]||(i[t]={});for(let a in e)Bagel.internal.subFunctions.createSprite.register.subMethods(e[a],a,n,i[t],r)}else((e,t,n,i,r)=>{let a=e.fn;a.normal?i[r]=a.fn:a.obArg?i[r]=(i=>{null==i&&(i={}),"object"!=Bagel.internal.getTypeOf(i)&&(console.error("Huh, looks like you used "+Bagel.internal.an(Bagel.internal.getTypeOf(i))+" instead of an object."),Bagel.internal.oops(n)),i=Bagel.check({ob:i,syntax:a.args,where:"the sprite "+JSON.stringify(t.id)+"'s "+JSON.stringify(r)+" method"},Bagel.internal.checks.disableArgCheck);let s=Bagel.internal.current;Bagel.internal.saveCurrent(),s.sprite=t,s.game=n,s.plugin=e.internal.plugin;let o=a.fn(t,i,n,s.plugin);return Bagel.internal.loadCurrent(),o}):i[r]=((...i)=>{let s=Object.keys(a.args),o={};for(let e in i)null==s[e]&&(s[e]="Your "+Bagel.internal.th(parseInt(e))+" argument"),o[s[e]]=i[e];o=Bagel.check({ob:o,syntax:a.args,where:"the sprite "+JSON.stringify(t.id)+"'s "+JSON.stringify(r)+" method"},Bagel.internal.checks.disableArgCheck,!1,"Btw, the arguments go in this order: "+s.join(", ")+".");let l=Bagel.internal.current;Bagel.internal.saveCurrent(),l.sprite=t,l.game=n,l.plugin=e.internal.plugin;let d=a.fn(t,o,n,l.plugin);return Bagel.internal.loadCurrent(),d})})(e,n,r,i,t)},methods:(e,t)=>{let n=t.internal.combinedPlugins.methods.sprite[e.type];if(null!=n)for(let i in n)Bagel.internal.subFunctions.createSprite.register.subMethods(n[i],i,e,e,t)},listeners:(e,t,n)=>{let i=t.internal.combinedPlugins.types.sprites[e.type],r=i.listeners;e.internal.Bagel.properties={};for(let n in r.property){let a=r.property[n];if(["object","array"].includes(Bagel.internal.getTypeOf(e[n]))&&a.subListen){e.internal.Bagel.properties[n]=Bagel.internal.deepClone(e[n]),Object.defineProperty(e,n,{writable:!1});for(let r in e[n])((e,t,n,i,r,a,s)=>{let o=r=>(Bagel.internal.triggerSpriteListener("get",t,e,i,!1,n),s[t][n]),l=r=>{if(s[t][n]!=r){let a=s[t][n];s[t][n]=r,Bagel.internal.triggerSpriteListener("set",t,e,i,!1,n,a)}};(a.get||a.set)&&(a.get&&a.set?Object.defineProperty(e[t],n,{get:o,set:l}):a.get?Object.defineProperty(e[t],n,{get:o,set:e=>{s[t][n]=e}}):Object.defineProperty(e[t],n,{get:e=>s[t][n],set:l}))})(e,n,r,t,i.internal.plugin,a,e.internal.Bagel.properties)}else e.hasOwnProperty(n)&&(e.internal.Bagel.properties[n]=e[n]),((e,t,n,i,r,a)=>{let s=i=>(Bagel.internal.triggerSpriteListener("get",t,e,n,!1),a[t]),o=i=>{if(a[t]!=i){let r=a[t];a[t]=i,Bagel.internal.triggerSpriteListener("set",t,e,n,!1,null,r)}};(r.get||r.set)&&(r.get&&r.set?Object.defineProperty(e,t,{get:s,set:o}):r.get?Object.defineProperty(e,t,{get:s,set:e=>{a[t]=e}}):Object.defineProperty(e,t,{get:e=>a[t],set:o}))})(e,n,t,i.internal.plugin,a,e.internal.Bagel.properties)}}},initRender:(e,t)=>{let n=t.internal.combinedPlugins.types.sprites[e.type],i=n.internal.plugin,r=Bagel.internal.current;Bagel.internal.saveCurrent(),r.sprite=e,r.game=t,r.plugin=i,n.render.init&&Bagel.internal.processSpriteRenderOutput(e,n.render.init(e,Bagel.internal.render.bitmapSprite.new,t,i)),Bagel.internal.loadCurrent()}},tick:{scripts:(e,t,n,i)=>{if(null==Bagel.internal.games[n.id])return;let r;if(null==(r=t?"all"==e?n.internal.scripts.index.sprites[e]:n.internal.scripts.index.sprites[e][i]:"all"==e?n.internal.scripts.index[e]:n.internal.scripts.index[e][i]))return;let a={};for(let i in r){let s=r[i];if(null!=s)if(t){let t,i=s.sprite;if(Bagel.internal.current.sprite=i,null==n.internal.idIndex[i.id])continue;if("init"==e&&i.scripts.init[s.script].affectVisible&&(i.internal.Bagel.rerunIndex.visible?i.internal.Bagel.properties.visible=!0:i.visible=!0),"function"==typeof(t="all"==e||i.isClone?i.scripts[e][s.script]:i.scripts[e][s.script].code)){a[i.id]||(a[i.id]=!0,i.debug.scriptTime=0);let e=performance.now();t(i,n,Bagel.step.sprite),i.debug.scriptTime+=performance.now()-e}}else{let t;(t="all"==e?n.game.scripts[e][s.script]:n.game.scripts[e][s.script].code)(n,Bagel.step.sprite)}}},pluginScripts:e=>{for(let t in e.internal.plugins){let n=e.internal.plugins[t];Bagel.internal.saveCurrent(),Bagel.internal.current.plugin=n,n.plugin.scripts.main&&n.plugin.scripts.main(n,e,Bagel.step.plugin.scripts),Bagel.internal.loadCurrent()}},hideSprites:e=>{let t=e.game.sprites,n=0;for(;n<t.length;){let e=t[n];null!=e?(e.isClone?e.delete():0==e.scripts.all.length&&(e.visible=!1),n++):n++}},render:{canvas:{init:e=>{let t=e.internal.renderer;t.maxTextureSlots=1/0,t.maxTextureSize=1/0,t.maxViewportSize=1/0,t.ctx=t.canvas.getContext("2d"),t.ctx.imageSmoothingEnabled=e.config.display.antialiasing},tick:e=>{let t=e.internal.renderer,n=t.canvas,i=t.ctx,r=(e.internal.renderer.scaleX,e.internal.renderer.scaleY,e.internal.combinedPlugins.types.sprites,Bagel.internal.subFunctions.tick.render.canvas);r.queues.bitmapLayers(e);let a=e.config.display.backgroundColor;"transparent"==a?i.clearRect(0,0,n.width,n.height):(i.fillStyle=a,i.fillRect(0,0,n.width,n.height));t.textures;let s=[];for(let n in t.layers){let a=t.scaledBitmaps[t.layers[n]];if(a){let o=Math.sign(a.width),l=Math.sign(a.height);i.scale(o,l),i.globalAlpha=a.alpha;let d=a.width/2,u=a.height/2,g=r.getTint(a,e,t);if(90==a.rotation){let e=a.x*o,t=a.y*l,n=a.width,r=a.height;a.crop?i.drawImage(g,a.crop.x,a.crop.y,a.crop.width,a.crop.height,e,t,n,r):i.drawImage(g,e,t,n,r)}else{let e=Bagel.maths.degToRad(a.rotation-90);i.scale(o,l),i.translate((a.x+d)*o,(a.y+u)*l),i.rotate(e*Math.min(o,l)),a.crop?i.drawImage(g,a.crop.x,a.crop.y,a.crop.width,a.crop.height,-d,-u,a.width,a.height):i.drawImage(g,-d,-u,a.width,a.height)}i.setTransform(1,0,0,1,0,0),s.push(t.layers[n])}}t.layers=s,i.globalAlpha=1},queues:{bitmapLayers:e=>{let t=e.internal.renderer;if(0==t.bitmapSpriteData.length||1==t.bitmapSpriteData.length)return void(t.queue.bitmap.layer=[]);let n=t.queue.bitmap.layer,i=t.bitmapIndexes,r=t.layers;if(0!=n.length)for(let e in n){if(null==n[e])continue;let a,s,o=n[e][0];switch(n[e][1]){case 0:if((a=i[o])==t.bitmapCount-1)break;for(r.splice(a,1),r.push(o),s=0;s<i.length;)i[s]>a&&i[s]--,s++;i[o]=t.bitmapCount-1;break;case 1:if((a=i[o])==t.bitmapCount-1)break;r.splice(a,1),r.splice(a+1,0,o),i[r[a+1]]--,i[o]++;break;case 2:if(0==(a=i[o]))break;for(r.splice(a,1),r.splice(0,0,o),s=0;s<i.length;)null!=i[s]&&i[s]<a&&i[s]++,s++;i[o]=0;break;case 3:if(0==(a=i[o]))break;r.splice(a,1),r.splice(a-1,0,o),i[r[a-1]]++,i[o]--}}t.queue.bitmap.layer=[],t.layers=r}},scaleData:(e,t)=>{e={...e};let n=t.scaleX,i=t.scaleY;t.canvas;return 90==e.rotation?(e.x-=Math.abs(e.width)/2,e.y-=Math.abs(e.height)/2):(e.x-=e.width/2,e.y-=e.height/2),e.width=Math.ceil((e.width+e.x)*n)-e.x*n,e.height=Math.ceil((e.height+e.y)*i)-e.y*i,e.x=Math.round(e.x*n),e.y=Math.round(e.y*i),e},getTint:(e,t,n)=>e.tint?n.tintedTextures[e.image][e.tint][0]:n.textures[e.image]},webgl:{compileShader:(e,t,n,i)=>{let r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),r},queues:{bitmap:e=>{let t=e.internal.renderer,n=t.gl,i=t.queue.bitmap;if(0!=t.queueLengths.add||0!=t.queueLengths.delete){let e=t.queueLengths.add-t.queueLengths.delete,r=new Float32Array(t.vertices.length+12*e),a=new Float32Array(t.textureCoordinates.length+24*e),s=t.bitmapIndexes,o=0,l=0,d=0,u=0,g=0;for(;d<t.vertices.length;){let e=d/12;i.delete[e]?(r.set(t.vertices.slice(o,d),l),a.set(t.textureCoordinates.slice(2*o,2*d),2*l),g++,l=u,o=d+=12):(0!=g&&(s[s.indexOf(e)]-=g),u+=12,d+=12)}r.set(t.vertices.slice(o,d),l),a.set(t.textureCoordinates.slice(2*o,2*d),2*l),previousCount=u/12;let h=2*u;d=u,u=0;let c=0;for(;u<i.new.length;){let e=i.new[u];if(e){t.bitmapIndexes[e[1]]=previousCount+c,e=e[0],r[d]=e.x-Math.abs(e.width/2),r[d+1]=e.y-Math.abs(e.height/2),r[d+2]=e.x+Math.abs(e.width/2),r[d+3]=r[d+1],r[d+4]=r[d],r[d+5]=e.y+Math.abs(e.height/2),r[d+6]=r[d],r[d+7]=r[d+5],r[d+8]=r[d+2],r[d+9]=r[d+1],r[d+10]=r[d+2],r[d+11]=r[d+5];let n=Bagel.internal.subFunctions.tick.render.webgl;n.rotateVertices(r,d,e.rotation,e.x,e.y),n.clipVertices(r,d,t);let i=t.textures[e.image],s=i[1],o=e.alpha,l=i[2],u=i[4];-1==Math.sign(e.width)&&(l=i[4],u=i[2]);let g=i[3],p=i[5];-1==Math.sign(e.height)&&(g=i[5],p=i[3]),a[h]=l,a[h+1]=g,a[h+2]=s,a[h+3]=o,a[h+4]=u,a[h+5]=g,a[h+6]=s,a[h+7]=o,a[h+8]=l,a[h+9]=p,a[h+10]=s,a[h+11]=o,a[h+12]=l,a[h+13]=p,a[h+14]=s,a[h+15]=o,a[h+16]=u,a[h+17]=g,a[h+18]=s,a[h+19]=o,a[h+20]=u,a[h+21]=p,a[h+22]=s,a[h+23]=o,d+=12,h+=24,c++}u++}n.bindBuffer(n.ARRAY_BUFFER,t.buffers.images),n.bufferData(n.ARRAY_BUFFER,a,n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,t.buffers.vertices),n.bufferData(n.ARRAY_BUFFER,r,n.DYNAMIC_DRAW),t.verticesUpdated=!1,t.vertices=r,t.textureCoordinates=a,i.new=[],i.delete={},t.queueLengths.add=0,t.queueLengths.delete=0}},bitmapLayers:e=>{let t=e.internal.renderer,n=(t.gl,t.queue.bitmap.layer);if(0!=t.vertices.length&&12!=t.vertices.length){if(0!=n.length){let e=Array.from(t.vertices),i=Array.from(t.textureCoordinates),r=t.bitmapIndexes;for(let t in n){let a=n[t];if(null==a)continue;let s,o,l,d,u=a[0];switch(a[1]){case 0:if(12*(s=r[u])==e.length-12)break;for(o=e.slice(12*s,12*s+12),l=i.slice(24*s,24*s+24),e.splice(12*s,12),i.splice(24*s,24),e.push(...o),i.push(...l),d=0;d<r.length;)r[d]>s&&r[d]--,d++;r[u]=e.length/12-1;break;case 1:if(12*(s=r[u])==e.length-12)break;o=e.slice(12*s,12*s+12),l=i.slice(24*s,24*s+24),e.splice(12*s,12),i.splice(24*s,24),e.splice(12*s+12,0,...o),i.splice(24*s+24,0,...l),r[r.indexOf(s+1)]--,r[u]++;break;case 2:if(0==(s=r[u]))break;for(o=e.slice(12*s,12*s+12),l=i.slice(24*s,24*s+24),e.splice(12*s,12),i.splice(24*s,24),e.splice(0,0,...o),i.splice(0,0,...l),d=0;d<r.length;)r[d]<s&&r[d]++,d++;r[u]=0;break;case 3:if(0==(s=r[u]))break;o=e.slice(12*s,12*s+12),l=i.slice(24*s,24*s+24),e.splice(12*s,12),i.splice(24*s,24),e.splice(12*s-12,0,...o),i.splice(24*s-24,0,...l),r[r.indexOf(s-1)]++,r[u]--}}e=new Float32Array(e),i=new Float32Array(i),t.vertices=e,t.textureCoordinates=i,t.queue.bitmap.layer=[],t.verticesUpdated=!0}}else t.queue.bitmap.layer=[]},texturemaps:e=>{let t=e.internal.renderer,n=t.gl,i=t.queue.texturemapsUpdated;for(let e in i){n.activeTexture(n.TEXTURE0+parseInt(e));let i=t.textureSlots[e],r=i.canvas;null==r&&(r=i[3]?i[3]:t.blankTexture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,r)}t.queue.texturemapsUpdated={}}},rotateVertices:(e,t,n,i,r)=>{let a=Bagel.maths.degToRad(n-90),s=-Math.sin(a),o=Math.cos(a),l=0;for(;l<6;){let n=e[t],a=e[t+1];e[t]=o*(n-i)+s*(a-r)+i,e[t+1]=o*(a-r)-s*(n-i)+r,l++,t+=2}return e},clipVertices:(e,t,n)=>{let i=n.scaleX,r=n.scaleY,a=n.canvas,s=0;for(;s<6;){let n=e[t],o=e[t+1];e[t]=1==s||4==s||5==s?Math.ceil(n*i)/a.width*2-1:Math.floor(n*i)/a.width*2-1,e[t+1]=2==s||3==s||5==s?-(Math.ceil(o*r)/a.height*2-1):-(Math.floor(o*r)/a.height*2-1),s++,t+=2}n.verticesUpdated=!0},processTextures:(e,t)=>{let n=Bagel.internal.render.texture.internal;for(let i in t.textures){let r=t.textures[i];if(r[12]){if(!r[16]&&(r[17]++,60==r[17])){let a=Bagel.internal.render.texture,s=r[15],o=r[13],l=t.bitmapsUsingTextures[i];a.delete(i,e,!1,!0,!0),a.new(i,s,e,!1,o,!1,!0),t.bitmapsUsingTextures[i]=l,n.regenerateBitmapCoords(i,t,e)}}else if(r[16]||(r[14]=0),3==r[14]||("animated"==r[13]||"auto"==r[13])&&r[14]>=1)if(t.textureSlotsUsed/t.maxTextureSlots<.9||"animated"==r[13]){let a=Bagel.internal.render.texture,s=r[15],o=r[13],l=t.bitmapsUsingTextures[i];a.delete(i,e,!1,!1,!0),a.new(i,s,e,!1,o,!0,!0),t.bitmapsUsingTextures[i]=l,n.regenerateBitmapCoords(i,t,e)}else r[16]=2;t.textures[i][16]=!1}},init:e=>{let t=e.internal.renderer,n=t.gl,i=Bagel.internal.subFunctions.tick.render.webgl.compileShader,r=i(n.VERTEX_SHADER,"\n                                attribute vec2 a_vertices;\n                                attribute vec4 a_textcoord;\n\n                                varying vec4 v_texcoord;\n\n                                void main () {\n                                    v_texcoord = a_textcoord;\n                                    gl_Position = vec4(\n                                        a_vertices,\n                                        0,\n                                        1\n                                    );\n                                }\n                            ",n,e),a=Bagel.device.webgl.textureCountLimit;t.maxTextureSlots=a,t.maxTextureSize=Bagel.device.webgl.textureSizeLimit,t.maxViewportSize=Bagel.device.webgl.viewportSizeLimit;let s="",o=1;for(;o<a;)s+="\n                                else if (textureID == <c>) {\n                                    pixel = texture2D(u_images[<c>], v_texcoord.xy);\n                                }".replaceAll("<c>",o),o++;let l=i(n.FRAGMENT_SHADER,"\n                                precision mediump float;\n                                uniform sampler2D u_images[<textureCount>];\n                                varying vec4 v_texcoord;\n\n                                // From https://gamedev.stackexchange.com/questions/34278/can-you-dynamically-set-which-texture-to-use-in-shader\n\n                                vec4 pixel = vec4(0.0, 0.0, 0.0, 0.0);\n                                vec4 getPixel () {\n                                    int textureID = int(v_texcoord.z);\n                                    if (textureID == 0) {\n                                        pixel = texture2D(u_images[0], v_texcoord.xy);\n                                    }[...]\n                                    return pixel;\n                                }\n\n                                void main () {\n                                    pixel = getPixel();\n                                    pixel.rgb *= pixel.a * v_texcoord.a;\n                                    pixel.a *= v_texcoord.a;\n\n                                    gl_FragColor = pixel;\n                                }\n                            ".replace("[...]",s).replace("<textureCount>",a),n,e),d=n.createProgram();n.attachShader(d,r),n.attachShader(d,l),n.linkProgram(d),n.getProgramParameter(d,n.LINK_STATUS)||(console.error("Err... a Bagel.js shader program failed to link. That wasn't supposed to happen."),console.log(n.getProgramInfoLog(d)),n.deleteProgram(d),Bagel.internal.oops(e)),n.useProgram(d),n.blendFunc(n.ONE,n.ONE_MINUS_SRC_ALPHA),n.enable(n.BLEND),t.locations.images=n.getUniformLocation(d,"u_images"),n.uniform1iv(t.locations.images,[...Array(a).keys()]);let u=n.getAttribLocation(d,"a_vertices");n.enableVertexAttribArray(u),t.buffers.vertices=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,t.buffers.vertices),n.vertexAttribPointer(u,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,t.vertices,n.DYNAMIC_DRAW);let g=n.getAttribLocation(d,"a_textcoord");n.enableVertexAttribArray(g),t.buffers.images=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,t.buffers.images),n.vertexAttribPointer(g,4,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,t.textureCoordinates,n.STATIC_DRAW);let h=t.blankTexture,c=0;for(;c<a;){let e=n.createTexture();n.activeTexture(n.TEXTURE0+c),n.bindTexture(n.TEXTURE_2D,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,h),t.textureSlots.push([!0,e]),c++}t.locations.vertices=u,t.locations.textures=g,t.webGLInitialized=!0},tick:e=>{let t=e.internal.renderer,n=t.gl,i=Bagel.internal.subFunctions.tick.render.webgl,r=i.queues;i.processTextures(e,t),r.bitmap(e),r.bitmapLayers(e),r.texturemaps(e);let a=e.config.display.backgroundColor;if(a!=t.lastBackgroundColor){t.colorCtx.fillStyle=a,t.colorCtx.fillRect(0,0,1,1);let e=t.colorCtx.getImageData(0,0,1,1).data;t.backgroundColor=[...e].map(e=>e/255),t.lastBackgroundColor=a}n.clearColor(...t.backgroundColor),n.clear(n.COLOR_BUFFER_BIT),0!=t.vertices.length&&(t.verticesUpdated&&(n.bindBuffer(n.ARRAY_BUFFER,t.buffers.images),n.bufferData(n.ARRAY_BUFFER,t.textureCoordinates,n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,t.buffers.vertices),n.bufferData(n.ARRAY_BUFFER,t.vertices,n.DYNAMIC_DRAW),t.verticesUpdated=!1),n.drawArrays(n.TRIANGLES,0,t.vertices.length/2))}}},spriteRenderTick:e=>{for(let t in e.game.sprites){let n=e.game.sprites[t];if(null!=n&&!n.internal.Bagel.rendererNotInitialized){let t=e.internal.combinedPlugins.types.sprites[n.type],i=Bagel.internal.render.bitmapSprite;t.render.tick&&Bagel.internal.processSpriteRenderOutput(n,t.render.tick(n,i.update,i.new,i.delete,e,t.internal.plugin)),n.internal.Bagel.properties.visible&&n.internal.Bagel.onVisibleTriggered&&t.render.whileVisible&&Bagel.internal.processSpriteRenderOutput(n,t.render.whileVisible(n,i.update,i.new,i.delete,e,t.internal.plugin))}}},processSprites:e=>{if(null!=Bagel.internal.games[e.id])for(let t in e.game.sprites){let n=e.game.sprites[t];null!=n&&Bagel.internal.processSprite(n)}else sprite.internal.Bagel.rerunListeners=[]},loaded:(e,t)=>{let n=Bagel.internal.subFunctions.tick,i=e.internal.renderer;if(!e.paused){n.pluginScripts(e),n.processSprites(e);let r,a=e.state;if(a!=e.internal.lastState){if(Bagel.internal.triggerPluginListener("state",e,a),0!=e.internal.assets.loading)return e.loaded=!1,!0;n.hideSprites(e),n.scripts("init",!0,e,a),n.scripts("init",!1,e,a),e.internal.lastState=a}if(n.scripts("main",!0,e,a),n.scripts("main",!1,e,a),n.scripts("all",!0,e,a),n.scripts("all",!1,e,a),null==Bagel.internal.games[e.id])return;n.spriteRenderTick(e),"canvas"==i.type?(r=performance.now(),e.scriptTime=r-t):e.internal.scriptEndTime=performance.now(),n.render[e.internal.renderer.type].tick(e),"canvas"==i.type&&(e.renderTime=performance.now()-r,e.frameTime=e.scriptTime+e.renderTime)}},loading:e=>{if(!e.config.loading.skip){let t=e.internal.renderer,n=(t.canvas,t.ctx,e.internal.loadingScreen),i=e.internal.assets,r=n.vars.loading;if(i.loading+i.loaded==0?r.progress=100:r.progress=i.loaded/(i.loading+i.loaded)*100,r.loaded=i.loaded,r.loading=i.loading,0!=i.loading){let t=e.game.scripts.preload;if(i.loading<=i.assetsLoading)if(i.ranTasks)t.misc&&1==i.loading&&(t.misc(e),i.loaded++,i.loading--);else{let n=(e=>t=>{e.loaded++,e.loading--})(i);for(let i in t.tasks)t.tasks[i](e,n);i.ranTasks=!0}}n.vars.loading.done&&(e.loaded=!0,Bagel.internal.subFunctions.init.deleteLoadingScreen(e),Bagel.internal.subFunctions.init.onload(e))}},tick:e=>{Bagel.internal.requestAnimationFrame.call(window,Bagel.internal.tick)},scaleCanvas:e=>{let t,n,i=window.innerWidth,r=window.innerHeight,a=e.internal.renderer,s=a.ratio,o=i/s;r>o?r=o:r!=o&&(i=r*s);let l=e.config.display.resolution;"full"==l?(t=i*window.devicePixelRatio,n=r*window.devicePixelRatio):"fixed"==l?(t=e.width,n=e.height):(t=l[0],n=l[1]),t=Math.ceil(t),n=Math.ceil(n),i=Math.round(i),r=Math.round(r);let d=a.maxViewportSize;(t>d||n>d)&&(t>n?(t=d,n=Math.ceil(t/s)):(n=d,t=Math.ceil(n*s)));let u=a.canvas;if((u.width!=t||u.height!=n)&&a.waitingWidth==t&&a.waitingHeight==n){u.width=t,u.height=n,a.scaleX=u.width/e.width,a.scaleY=u.height/e.height,a.gl&&a.gl.viewport(0,0,a.canvas.width,a.canvas.height);for(let t in a.bitmapIndexes){let n=a.bitmapSpriteData[t];n&&Bagel.internal.render.bitmapSprite.update(t,n,e,!1,!0)}}u.style.width=i+"px",u.style.height=r+"px",a.styleWidth=i,a.styleHeight=r;let g=(window.innerWidth-i)/2;u.style.marginLeft=Math.floor(g)+"px",u.style.marginRight=-Math.ceil(g)+"px";let h=(window.innerHeight-r)/2;u.style.marginTop=Math.floor(h)+"px",u.style.marginBottom=-Math.ceil(h)+"px",e.config.display.antialiasing||Bagel.internal.tryStyles(u,"image-rendering",["pixelated","optimize-contrast","-moz-crisp-edges","-o-crisp-edges","-webkit-optimize-contrast","optimizeSpeed"]),a.waitingWidth=t,a.waitingHeight=n,"canvas"==a.type&&a.ctx&&(a.ctx.imageSmoothingEnabled=e.config.display.antialiasing)},calculateRenderTime:e=>{let t=1e3/(performance.now()-Bagel.internal.frameStartTime);for(let e in Bagel.internal.games){let n=Bagel.internal.games[e];if(n){let e=performance.now()-n.internal.scriptEndTime;"canvas"!=n.internal.renderer.type&&(n.renderTime=e,n.frameTime=n.scriptTime+e),n.maxPossibleFPS=t}}}},delete:{event:(e,t,n)=>{let i=t.internal.combinedPlugins.types.sprites[e.type];n.plugin=i.internal.plugin,(i=i.listeners.events.delete)&&i(e,t)},bitmapSprite:(e,t)=>{null!=e.internal.Bagel.renderID&&Bagel.internal.render.bitmapSprite.delete(e.internal.Bagel.renderID,t)},scripts:(e,t,n)=>{let r=t.internal.Bagel.scripts[e];if(0==Object.keys(r).length)return;let a=n.internal.scripts.index.sprites[e];for(let t in r){let n=r[t];"all"==e?a[n.id]=null:a[n.state][n.id]=null}let s=[];for(i in a){let t=0;"all"!=e&&(s=[]);let n="all"==e?"a":a[i];for(let r in n){let o;null==(o="all"==e?a[i]:n[r])?t++:(0!=t&&("all"==e?o.sprite.internal.Bagel.scripts[o.script].id-=t:o.sprite.internal.Bagel.scripts[e][o.script].id-=t),s.push(o))}"all"!=e&&(a[i]=s)}"all"==e&&(n.internal.scripts.index.sprites[e]=s)},misc:(e,t)=>{if(t.game.sprites[e.idIndex]=null,t.internal.idIndex[e.id]=null,e.isClone){e.parent.cloneCount--;let t=e.parent.cloneIDs.indexOf(e.id);e.parent.cloneIDs.splice(t,1)}e.deleteClones()}}},checks:{game:{id:{required:!0,check:e=>{if(null!=Bagel.internal.games[e])return"Oh no! You used an id for your game that is already being used. Try and think of something else.\nYou used "+JSON.stringify(e)+' in "Game.id".';let t=Bagel.internal.getActingPluginId(),n=e.split(".")[1];"."==e[0]&&(null==t?(console.error("This is awkward... IDs starting with a dot are only for plugins. You tried to use the id "+JSON.stringify(e)+". In Game.id.\nIf it's important that it has this name, you could write a plugin instead, just make sure its id is set to "+JSON.stringify(n)+" ;)"),Bagel.internal.oops()):n!=t&&(console.error("Erm... the only reserved prefix you can use in this plugin is "+JSON.stringify("."+t)+" and you tried to use the id "+JSON.stringify(e)+'In Game.id.\nYou can fix this by changing the prefix, removing it or changing the plugin id in "Plugin.info.id".'),Bagel.internal.oops()))},types:["string"],description:"An id for the game canvas so it can be referenced later in the program."},width:{required:!0,types:["number"],description:"The virtual width for the game. Independent from the rendered width."},height:{required:!0,types:["number"],description:"The virtual height for the game. Independent from the rendered height."},game:{required:!1,default:{},subcheck:{assets:{required:!1,default:{},types:["object"],description:"The assets you want to load for your game, organised by type. e.g imgs: [<asset1>,<asset2>]"},sprites:{required:!1,default:[],types:["array"],description:"The array that contains the all the sprite JSON."},scripts:{required:!1,default:{},subcheck:{init:{required:!1,default:[],arrayLike:!0,subcheck:{code:{required:!0,types:["function"],description:'The code to be run when the "stateToRun" property matches the game state.'},stateToRun:{required:!0,types:["string"],description:"The state when this script will be run."},affectVisible:{required:!1,default:!0,types:["boolean"],description:"If the script should make the sprite visible or not when it runs."}},types:["array"],description:"Init scripts. They run on a state change."},main:{required:!1,default:[],arrayLike:!0,subcheck:{code:{required:!0,types:["function"],description:'The code to be run when the "stateToRun" property matches the game state.'},stateToRun:{required:!0,types:["string"],description:"The state when this script will be run."}},types:["array"],description:"Main scripts. They run every frame where the states match."},all:{required:!1,default:[],check:e=>{if("function"!=typeof e)return"Huh. This should be a function but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."},checkEach:!0,types:["array"],description:'"All" scripts. They run every frame regardless of game state.'},preload:{required:!1,default:{},subcheck:{tasks:{required:!1,default:[],types:["array"],check:e=>{if("function"!=typeof e)return"Oops, this is supposed to be a function but you tried to use "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."},checkEach:!0,description:"Tasks that need to be completed before the game loads (but after the assets have loaded). The arguments provided are the game object followed by a ready function. This function must be called once the task is completed (otherwise the game won't load)."},misc:{required:!1,types:["function"],description:"A function for performing miscellaneous preload tasks that can be completed asynchronously. The function is called with the game object as its first argument."}},types:["object"],description:'Code that needs to be run before the game can load. "tasks" and "misc".'}},types:["object"],description:'The object that contains all the game scripts ("init" and "main") that aren\'t for a sprite.'},plugins:{required:!1,default:[],arrayLike:!0,subcheck:{src:{required:!0,types:["string"],description:"The src of the plugin file. Should be a json or js file."},options:{required:!1,types:["object"],description:"May not apply to all plugins but includes options for how they behave."}},types:["array"],description:"The plugins to load for this game. Plugins enhance Bagel.js' abilities or make certain things easier."}},types:["object"],description:"Where most of the properties are."},state:{required:!0,types:["string"],description:"The game's initial state. Game states control which sprites are active."},config:{required:!1,default:{},subcheck:{display:{required:!1,default:{},types:["object"],subcheck:{mode:{required:!1,default:"fill",check:e=>{if(!["fill","static"].includes(e))return"Oops! You used an invalid option. You used "+JSON.stringify(e)+', it can only be either "fill" or "static".'},types:["string"],description:"The display mode. e.g static (always the same size) or fill (fills the whole window)."},resolution:{required:!1,default:"full",types:["string","array"],check:e=>{if("string"==typeof e){if(!["full","fixed"].includes(e))return'Oops, this can only be "full", "fixed" or a custom resolution using an array.'}else{if(!Array.isArray(e))return"Erm, this can only be a number or an array.";if(2!=e.length)return"Huh, the array can only have two items: the width and height to render at.";if("number"!=typeof e[0])return"Hmm, looks like the first item of the custom resolution isn't a number, it's "+Bagel.internal.an(Bagel.internal.getTypeOf(e[0]))+".";if("number"!=typeof e[1])return"Oops, looks like the second item of the custom resolution isn't a number, it's "+Bagel.internal.an(Bagel.internal.getTypeOf(e[1]))+"."}},description:'The resolution for the game to be rendered at. Either "full", "fixed" or a custom resolution using an array containing the width and height (in that order). Full renders the game at the full resolution which makes it good for vector graphics. Fixed is good for pixel art because it means that resources aren\'t wasted rendering extra pixels as it renders at the game\'s width and height. And custom\'s good if you want to do something more advanced.'},antialiasing:{required:!1,default:!1,types:["boolean"],description:"If antialiasing is used or not. Antialiasing smooths out lower resolution stuff at the a slight cost to performance. However, it doesn't work well with pixel art so should be disabled for that. Disabling it also rounds coordinates during the rendering which removes fuzzy edges but can make motion less smooth."},renderer:{required:!1,default:"canvas",check:e=>{if(!["auto","canvas","webgl"].includes(e))return"Oops. You used an invalid option. You used "+JSON.stringify(e)+', it can only be either "auto", "canvas" or "webgl".'},types:["string"],description:'The renderer for this game. Either "auto", "canvas" or "webgl". "auto" will use WebGL if it\'s supported by the browser, otherwise it\'ll use the basic 2d canvas renderer (slower).'},dom:{required:!1,default:!0,types:["boolean"],description:"If the canvas should be part of the DOM or not."},htmlElementID:{required:!1,check:e=>{if(null==document.getElementById(e)&&null!=e)return"Oops, you specified the element to add the game canvas to but it doesn't seem to exist.\nYou tried to use "+JSON.stringify(e)+". You might want to check that the HTML that creates the element is before your JavaScript."},types:["string"],description:"An element to append the canvas to. If unspecified, it will be added to the document or body."},backgroundColor:{required:!1,default:"white",types:["string"],description:'The HTML colour for the canvas background. Can also be "transparent".'},webgl:{required:!1,default:{},types:["object"],subcheck:{minimumLimits:{required:!1,default:{},types:["object"],subcheck:{textureCount:{required:!1,default:8,types:["number"],check:e=>{if(e<8)return"Oh no. It has to be 8 or more as all WebGL compatible GPUs support at least that."},description:"The minimum number of WebGL textures the GPU needs to support in order for the WebGL rendererer to be used. Static textures are combined into larger textures to reduce texture usage, however, this may be a limiting factor when using multiple large canvases."},textureSize:{required:!1,default:4096,types:["number"],check:e=>{if(e<4096)return"Huh, it has to be 4096 or more as all WebGL compatible GPUs support at least that."},description:"The minimum number limit for the both the width and height of each WebGL texture. Keep in mind that textures about this size take up a lot of VRAM so it will likely become a limiting factor if textures are created at the maximum size. Combined textures will continue to use a 4096x4096 resolution if this value is changed."}},description:'The minimum limits for the GPU. If the "auto" renderer mode is being used, the canvas renderer will be used instead if there requirements aren\'t met. If the "webgl" renderer mode is being used, an error will be displayed to the user and the game won\'t run.\nYou might want to use a tool like https://webglreport.com/ to find out the specs of different devices if you need to change some of these.'}},description:"A few options for the WebGL renderer."}},description:"Contains a few options for how the game is displayed."},input:{required:!1,default:{},subcheck:{touch:{required:!1,default:{},subcheck:{scroll:{required:!1,default:{},subcheck:{momentum:{required:!1,default:.94,check:e=>{if(e>=1||e<0)return"Oh no! This has to be between 0 (inclusive) and 1 (exclusive)."},types:["number"],description:"What the scroll velocity should be multiplied by each frame to reduce it. Only used for touch scrolling."},deadzone:{required:!1,default:5,types:["number"],description:"The minimum number of in game pixels a touch point must move from its original point to be registered as a scroll input and/or drag."}},types:["object"],description:"Some options related to scrolling for touch devices."}},types:["object"],description:"Some options for input on touch devices."},mouse:{required:!1,default:{},subcheck:{scrollSensitivity:{required:!1,default:.5,types:["number"],description:"The sensitivity for scrolling with the scroll wheel."}},types:["object"],description:""}},types:["object"],description:"Contains some options for how input is handled."},loading:{required:!1,default:{},subcheck:{mode:{required:!1,default:"dynamic",check:e=>{if(!["preload","dynamic"].includes(e))return'Oh no! This only accepts "preload" and "dynamic" but you used '+JSON.stringify(e)+"."},types:["string"],description:'How assets should be loaded. Either "preload" or "dynamic". Preload loads all the assets before the game runs and dynamic only loads the assets when they\'re requested internally or by using the get function. A loading screen will show for those assets if they were requested on the first frame after a state change. Assets requested any other time won\'t trigger a loading screen.'},skip:{required:!1,default:!0,types:["boolean"],description:"If the loading screen should be skipped or not. If true, nothing will show until the game's loaded. This can annoy the user as it delays the page load but if it's short enough it saves time because they don't have to wait for the loading animation to finish."},animation:{required:!1,default:{game:{assets:{imgs:[{id:"Bagel",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADEAAAAxCAYAAABznEEcAAAHBklEQVRoQ8Wa+28UVRTHz126s2C3u1BA0wpUQBBa3NKWl/6qoj/6iNGoMRo1RsVo1D9B8YFvFDWoEKOJifEHf/cVH7yKvAQi0iIsNa3RUlNI27CzHXPue2bvzNyZ3Uh/abePmfnc8z3nfM/ZEmjwh/vVeo8QgAwBAPwCP+OH9prcslt8tyF3r/tiE1+ukw/NnpmwZ48BYVCMjmzcVddzpP7j81+s9eThEvbgePppQRCI3JQOJjHE2Odr6MkTQthDC9XYgLQvBxj+3SctPSLia3JjMhhriL8/6/PYSSu5JAJBgJmtABfHokFcF8BpoqDkBjsYK4i/Pu1jpw9CMslBZixerxKdg3iuC8TJ8sioHJHRsQSJhRj+pNdz3So4TpMsNmki0oQQlXMAubkAF88BjJysqVomadlEJBJiaGevv/IIKQUi4rouOE42NEec9mUAuVYWCQQZPhlaftOAhEKUd/RwCQUqTwhIVLLPbL+aRQDvVhmD6eGTvj4yXXEhQ/NAVAr8PcwNv9TCcsQI8cdHPTyJ/SVTltCEILOuWicB3OEB2UdEBE0NUUYkAGMCqYEY3L7aX0IDtR9BkuRIM42CklJlZCBVQ4xK9hqIAYTQan+V6l0kdXJp5TvW8lwYg6mRgbobIk30QB/xQZz4oNvLaFLx6dwQEfy5jEpI+S1QCHYqk+V+2dndCisGYRYlrvzqID6I397v5tWI9wEtIioflD+yyZFim5ATS+rJkcGGWxQJcXwbA1AnQ4AmXpZLSdiMkIjITg4AVbcqrzNRAZiTz0KhbSn8e/YEl6bZa+H9cnqV0t3vlcvZww2fYF1R81oS4ti2kqc7UGbokkUEpYV/N1lR0Vry8CFy+mNeLIBAS449i5BSrGkUfmvJdaxJaiDC/VKII++UVEnVrHQSECwAExUGfc2jh2P7D8JYgSzeoAwjhQDlvbiNpzc7vLUUOhPYgGAE8PQ7HzsSa2PEFHR2Z48XCyJMo2iCp/f4GyJKauNu/CnAobev9YSmTeFFjeveSa9aqOPJCoFVT9gDxIFkqU3hHR7NIvoscTyy/vPUuJlDHHwLIZTNNoGYIoJwky5AadOv1hEIzqPBiMzE7l4ZYw+dmwvTZ/bGjrpk/5urvAzPg2q1CllejWxA8PdRRt1PpodAj4aymt2xQnV2ftrumX00xyKrFh5+/xurWD74EpqAqVOL8itKKAL0PnU0dRREVBBk4bIV/PRbYarcn6izk32vMwgTSNjcjN+nUqoA9D1dP8SZHau9FofAnI4VMIHeymbU1XKE7H1NQSQBEfmwpgEQ2EfyOYAc2pCYmd0kLbLn1S5ZmUwREXmi50i1ihUJYN0zx+qWkpBUEhCRJ9hnaOfetaXLsACozZGgtBoJcupDFglWxtkWhRlE9jpM1mJBR37e0kWtd+3cHA2CDW6qArD+2fqjgTOMgki+DiI/vYJyYoUBpSMMH5PRjJqqJU6FQrgAGxoAMbC928s7RDVUy70WmwybgPz4cqfKiYQRaQQIzjA0CtkmqQb5cNqCToyyRmlhYiUFKV7eIbU7VD4F1z+XXlI4w0gppdhrObfuY97ph5cwGtp2LyQixfkdkHGKfFYgQNxx+npo8GAqkOPvlby8oxJayDrJXit3G4f4/sVObbuhZgj9YsX5i4BwADpnuOP8NYGx8gGYdEkikKPvlrxmn4ziR13T7nfW7Rziu80sEqZxkz18QS2QRclzx+H8P2VZAtGmIAheIyrZD29lZrNZRIDbHZtRF8ttVZZeppzL7uAQKCkTSGHeQshwAHHyGXz40bKxaiEIXhirlui82BDRZIrX+RzOj0JC9e218nf203SQHffbzSvleKqfSqGtS/UQlBAhcGEUI+DvI3pnF2MqXgc7e7OjFtDBmV1WIi0itnutliAEEgVBMBJSSu44XBg9G1jt23V2Ze+Tzez68iGY7LPv2i8D4PM+37yw0rd/LbZ1sodGgHNDIat9BWKaR+ipyo1J8uVDGMicu0MgMBoChEYhW4BMdRxItmgNkmZClG/WWKyDMCJz7/nFd/g1LvTr51k0CvMWUAh6gypKaYh+jRac2pGad43ipSVcsj7qqt0Wf/ssAKKGMyXF+ffGQGA0dJALo3/6XWTERpwuFDTphDlQdMCYJ0n3Wni9K+7zA/iqU3CAFyCsiyZZJKeLiDCgDE5tIvV7t91/wDi/RA41lwJE5FRwxl/wgBkgMhIiMpcSRERk0YMHIw/barwMA9FLathg5c8TJkt5yhYr08UPRQNYReL/iogp2Zc+csjqkK1+SU/6YEM0GTd9QhTrHZuqJUpw1ELa9B8tiSHERcK8VvhMEF+1Oh8P36ZH/TtOaghx0TAbz3JhBp3bhXcK22uVNiVfRutQdUMET8hm1G3Ewk2/73+GkYKJ4ZsYiQAAAABJRU5ErkJggg=="},{id:"Loading.Black",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACcAAAAGCAYAAABAU4emAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AYht+mSou0ONhBRCFDdbIgKuIoVSyChdJWaNXB5NI/aNKQpLg4Cq4FB38Wqw4uzro6uAqC4A+Ik6OToouU+F1SaBHjHcc9vPe9L3ffAUKzylSzZwJQNctIJ+JiLr8qBl4RwAjCNIMSM/VkZjELz/F1Dx/f72I8y7vuzxFWCiYDfCLxHNMNi3iDeGbT0jnvE0dYWVKIz4nHDbog8SPXZZffOJccFnhmxMim54kjxGKpi+UuZmVDJZ4mjiqqRvlCzmWF8xZntVpn7XvyF4YK2kqG67SGkcASkkhBhIw6KqjCQox2jRQTaTqPe/iHHH+KXDK5KmDkWEANKiTHD/4Hv3trFqcm3aRQHOh9se2PUSCwC7Qatv19bNutE8D/DFxpHX+tCcx+kt7oaNEjoH8buLjuaPIecLkDDD7pkiE5kp+WUCwC72f0TXlg4BboW3P71j7H6QOQpV4t3wAHh8BYibLXPd4d7O7bvzXt/v0AOZJykKeF/tkAAAAGYktHRAD/AOwAAJPfVTcAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfkBx0TEyFitOyDAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAIZJREFUKFPFkUEOQiEMRGeMN5D7n7D/DM8NaEEQXPkSAh0G2rSWBCEr4SJyTMg7jZD1QLbfGtg2+W7qG/JLkot0H8VGe/BRwEx7Jba7giouAmqci9xw2xn+ybJzM8bRntK62YlptKsu/tQ5Qj4ZxxGXBWz/Ii9irRFSPo8eoNdqnO+++ob9Cdg1gf0PGCdvAAAAAElFTkSuQmCC"},{id:"Loading.White",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACcAAAAGCAYAAABAU4emAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AYht+mSou0ONhBRCFDdbIgKuIoVSyChdJWaNXB5NI/aNKQpLg4Cq4FB38Wqw4uzro6uAqC4A+Ik6OToouU+F1SaBHjHcc9vPe9L3ffAUKzylSzZwJQNctIJ+JiLr8qBl4RwAjCNIMSM/VkZjELz/F1Dx/f72I8y7vuzxFWCiYDfCLxHNMNi3iDeGbT0jnvE0dYWVKIz4nHDbog8SPXZZffOJccFnhmxMim54kjxGKpi+UuZmVDJZ4mjiqqRvlCzmWF8xZntVpn7XvyF4YK2kqG67SGkcASkkhBhIw6KqjCQox2jRQTaTqPe/iHHH+KXDK5KmDkWEANKiTHD/4Hv3trFqcm3aRQHOh9se2PUSCwC7Qatv19bNutE8D/DFxpHX+tCcx+kt7oaNEjoH8buLjuaPIecLkDDD7pkiE5kp+WUCwC72f0TXlg4BboW3P71j7H6QOQpV4t3wAHh8BYibLXPd4d7O7bvzXt/v0AOZJykKeF/tkAAAAGYktHRAD/AOwAAJPfVTcAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfkBx0TEjVhdQm/AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAIlJREFUKFPNk8ERwyAMBPcy6cDpv0NquDw0OEKBYP+yLzgECOmQbdMkMoc9zJu01WIOkOMEeFibxdX7Ab3gUcWTJn1tWmkQiTZBJDRemB+Rk5ydl1gn9wc8dwEDtbXXifZmcmsX1btXuU0bbpEtsCAqV41dtV/0uGr00Lv/4HD/HDGe+fBTYdn4DcirSc3L3FGIAAAAAElFTkSuQmCC"}]},sprites:[{id:"Bagel",type:"canvas",fullRes:!1,updateRes:!1,visible:!1,mode:"animated",width:1,height:1,scripts:{init:[{code:(e,t)=>{e.vars.img=Bagel.get.asset.img("Bagel"),e.width=Math.max(t.width,t.height)/5,e.height=e.width,e.canvas.width=e.vars.img.width,e.canvas.height=e.canvas.width},stateToRun:"loading"}]},render:(e,t,n,i)=>{let r=e.vars.img,a=i.width/2;if(n.imageSmoothingEnabled=!1,n.fillStyle=t.config.display.backgroundColor,0!=t.vars.stage)return 0==t.vars.delay?(t.vars.velocity+=1,e.width-=t.vars.velocity,e.height-=t.vars.velocity,t.vars.velocity*=.9,e.width<=0&&(e.width=1,e.height=1,n.clearRect(0,0,1,1),t.vars.delay++)):(t.vars.delay++,t.vars.delay>10&&(t.vars.loading.done=!0)),!0;{n.clearRect(0,0,i.width,i.height),-90!=t.vars.angle&&n.drawImage(r,0,0,i.width,i.height);let e=t.vars.loading.progress/100*360-90;if(e>t.vars.angle&&(t.vars.velocity+=5,t.vars.angle+=t.vars.velocity,t.vars.velocity*=.9,e<=t.vars.angle&&(t.vars.velocity=0,t.vars.angle=e)),100==t.vars.loading.progress&&0==t.vars.velocity)return void t.vars.stage++;n.beginPath(),n.moveTo(a,a),n.arc(a,a,2*a,Bagel.maths.degToRad(-90),Bagel.maths.degToRad(t.vars.angle),!0),n.lineTo(a,a),n.fill(),n.setTransform(1,0,0,1,0,0)}}},{id:"Text",type:"sprite",img:"Loading.Black",scripts:{init:[{code:(e,t,n)=>{let i=document.createElement("canvas");i.width=1,i.height=1,e.vars.ctx=i.getContext("2d"),e.vars.halfBagelHeight=Bagel.get.sprite("Bagel").height/2,n("calculateSize"),n("calculateColor")},stateToRun:"loading"}],main:[{code:(e,t,n)=>{n("calculateColor"),n("calculateSize")},stateToRun:"loading"}],steps:{calculateSize:(e,t)=>{let n=e.height/e.width;e.width=Math.min(t.width,t.height)/2,e.height=e.width*n,e.y=t.height/2+e.vars.halfBagelHeight,e.y+=e.height},calculateColor:(e,t)=>{let n=e.vars.ctx,i=t.vars.loading.game.config.display.backgroundColor;"transparent"==i&&(i=document.body.bgColor),n.fillStyle=i;let r=i=n.fillStyle;(parseInt(r[1]+r[2],16)+parseInt(r[3]+r[4],16)+parseInt(r[5]+r[6],16))/3<=127&&(e.img="Loading.White")}}}}]},state:"loading",vars:{angle:-90,velocity:0,stage:0,delay:0},config:{display:{resolution:"full"}}},types:["object"],description:"The loading screen animation. Defaults to a Bagel.js themed one.\nIt's a game object and works exactly the same as a game except its loading screen is disabled, Game.vars.loading is automatically created and the id, width, height and config given for the game is ignored. Game.vars.loading contains the following:\n  progress -> The percentage of the assets loaded\n  loaded -> The number of assets loaded\n  loading -> The number currently loading\n  done -> Starts as false, set this to true when you're done (loaded should be 0 when you do this)"}},types:["object"],description:"A few options for how Bagel.js should handle loading assets."},disableBagelJSMessage:{required:!1,default:!1,types:["boolean"],description:"Disables the console message when the game is initialised. As crediting is required to use Bagel.js, please put a link to the GitHub page somewhere else in your program. e.g in the credits."},isLoadingScreen:{required:!1,default:!1,types:["boolean"],description:"If this game is a loading screen or not. Used internally."}},types:["object"],description:"A bunch of other options for the game."},internal:{required:!1,default:{},types:["object"],description:"Very hush hush. (Contains stuff that Bagel.js needs to make the game work)"},vars:{required:!1,default:{},types:["object"],description:"Can be used to store variables for the game."}},sprite:{sprite:{id:{required:!0,check:(e,t,n,i)=>{let r=Bagel.internal.getActingPluginId(),a=e.split(".")[1];if("."==e[0]){if(null==r)return"This is awkward... ids starting with a dot are only for plugins. You tried to use the id "+JSON.stringify(e)+".\nIf it's important that it has this name, you could write a plugin instead, just make sure its id (Plugin.info.id) is set to "+JSON.stringify(a)+" ;)";if(a!=r)return"Erm... the only reserved prefix you can use in this plugin is "+JSON.stringify("."+r)+" and you tried to use the id "+JSON.stringify(e)+'.\nYou can fix this by changing the prefix (the bit after a full stop starting but before the next full stop), removing it or changing the plugin id in "Plugin.info.id".'}if(i.internal.idIndex[t.id])return"Oops, you've used this id before. You might want to check what sprite has this id or if you're adding this sprite to the right game."},types:["string"],description:"The id for the sprite to be targeted by."},type:{required:!0,types:["string"],description:"The type of sprite."},visible:{required:!1,default:!0,types:["boolean"],description:"Mostly pointless setting here as the sprite will be made invisible unless it has an init script or it's a clone, and made visible if it has an init script and isn't a clone.\nIf the sprite is visible or not."},clones:{required:!1,default:{},check:(e,t,n,i,r)=>{let a=i.internal.combinedPlugins.types.sprites[t.type].internal.cloneSyntax;Bagel.check({ob:e,where:"the sprite "+JSON.stringify(t.id)+'\'s "clone" argument',syntax:a},{args:!0,missing:!0})},types:["object"],description:"The default data for a clone of this sprite.\nAll arguments are optional as the clone will adopt the arguments from the clone function and the parent sprite (in that priority)"},scripts:{required:!1,default:{},subcheck:{init:{required:!1,default:[],subcheck:{code:{required:!0,types:["function","undefined"],description:'The code to be run when the "stateToRun" property matches the game state.'},stateToRun:{required:!0,types:["string"],description:"The state when this script will be run."},affectVisible:{required:!1,default:!0,types:["boolean"],description:"If the script should make the sprite visible or not when it runs."}},arrayLike:!0,types:["array"],description:"Contains init scripts. They run when the game state first changes to the script's state."},main:{required:!1,default:[],arrayLike:!0,subcheck:{code:{required:!0,types:["function","undefined"],description:'The code to be run when the "stateToRun" property matches the game state.'},stateToRun:{required:!0,types:["string"],description:"The state when this script will be run."}},types:["array"],description:"Contains main scripts. They run for every frame where the script's state and the game's state match."},all:{required:!1,default:[],check:e=>{if("function"!=typeof e)return"Huh. This should be a function but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."},checkEach:!0,types:["array"],description:'Contains "all" scripts. They run on every frame and aren\'t affected by the game state.'},steps:{required:!1,default:{},types:["object"],description:"Contains steps: mini scripts that can be called from scripts. The key is the id and the value is the function."}},types:["object"],description:"The sprite's scripts."},vars:{required:!1,default:{},types:["object"],description:"An object you can use to store data for the sprite."},request:{required:!1,default:{},types:["object"],description:"Contains assets the sprite needs before it becomes active. Used as part of dynamic loading. The keys are the game states and the values are an object with the keys being the asset type (plural) and the value being an array of the assets of that type that need to be loaded."}},clones:{syntax:{id:{types:["string"],description:"The id for the clone to be targeted by. Defaults to the parent's id followed by a hashtag and then the lowest number starting from 0 that hasn't already been used."},type:{types:["string"],description:"The type of clone."},visible:{types:["boolean"],description:"If the clone is visible or not."},clones:{types:["object"],description:"The default data for a clone of this clone.\nAll arguments are optional as the clone will adopt the arguments from the clone function and the parent sprite (in that priority)"},scripts:{subcheck:{init:{required:!1,default:[],types:["array"],check:e=>{if("function"!=typeof e)return"Oops. Looks like you used the wrong type, you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+" instead of a function."},checkEach:!0,description:"An array of functions to run when this clone is initialised."},main:{required:!1,default:[],types:["array"],description:"An array of functions to run on every frame for this clone."},steps:{required:!1,default:{},types:["object"],description:"Contains steps: mini scripts that can be called from scripts. The key is the id and the value is the function."}},types:["object"],description:"The clones's scripts."},vars:{types:["object"],description:"An object you can use to store data for the clone."}},args:{id:{syntax:{description:"The id for the clone to be targeted by. Defaults to the parent's id followed by a hashtag and then the lowest number starting from 0 that hasn't already been used."},mode:"replace"},type:{syntax:{required:!0,types:["string"],description:"The type of clone."},mode:"replace"},visible:{syntax:{description:"If the clone is visible or not."},mode:"replace"},clones:{syntax:{required:!1,default:{},types:["object"],description:"The default data for a clone of this clone.\nAll arguments are optional as the clone will adopt the arguments from the clone function and the parent sprite (in that priority)"},mode:"ignore"},scripts:{syntax:{subcheck:{init:{required:!1,default:[],types:["array"],check:e=>{if("function"!=typeof e)return"Oops. Looks like you used the wrong type, you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+" instead of a function."},checkEach:!0,description:"An array of functions to run when this clone is initialised."},main:{required:!1,default:[],types:["array"],description:"An array of functions to run on every frame for this clone."}},description:"The clones's scripts.",default:{}},mode:"ignore"},vars:{syntax:{description:"An object you can use to store data for the clone."},mode:"merge"}}}},plugin:{info:{required:!0,types:["object"],subcheck:{id:{required:!0,check:e=>{if(Bagel.internal.current.game.internal.plugins[e])return"Oops, you used an id for a plugin that's already been used. You tried to use the id "+JSON.stringify(e)+" in the game "+JSON.stringify(Bagel.internal.current.game.id)+". This plugin might've already been loaded or maybe the plugins are too similar? If you're making this plugin, you could try changing Plugin.info.id."},types:["string"],description:"The unique id for the plugin."},description:{required:!0,types:["string"],description:"A brief description of what the plugin is and what it does."}},description:"Contains some information about the plugin."},plugin:{required:!1,default:{},subcheck:{types:{required:!1,default:{},subcheck:{assets:{required:!1,default:{},arrayLike:!0,subcheck:{args:{required:!0,types:["object"],description:["The required and optional arguments for the asset type. Is an object where the key is the argument name. e.g {","    foo: {","        required: false,","        default: 1,","        types: [",'            "number"',"        ],",'        description: "The first argument for this asset type.',"    }","}"].join("\n")},description:{required:!0,types:["string"],description:"The description of this asset type, make this short and clear to help people when they use the wrong syntax."},check:{required:!1,types:["function"],description:["Your check function for this asset type. ","A good check function will avoid a standard JavaScript error when the user inputs something wrong (e.g a can't read property X of null error).","\nFortunately, Bagel.js helps you out in a few ways:\n",'  You can use the check function provided (while the check function is being run) to easily check an object to make sure it has the desired properties as well as setting defaults. (works in the same way as the "args" argument.)\n','  You should also make use of the "args" argument as you can easily choose which data types you want to allow for each arguments as well as setting defaults and required arguments.\n','  "standardChecks" has, well... some standard checks. If you want to make sure an id isn\'t used twice use "standardChecks.id(<whichever argument is used for the id (defaults to "id")>)". ','  You might also want to use the "isInternal" check with the arguments working the same as the previous but also having a second argument for the isInternal argument. This might be useful if you want to reserve some IDs for plugins as it\'ll block any IDs starting with a dot and without the asset having "isInternal" set to true.\n',"  You probably want to use it like this:\n","    let error = standardChecks.id();\nif (error) return error;",'  And if you find any problems with the user input, just use the return statement in the check function (e.g return "Error";) and Bagel.js will stop what it\'s doing, throw the error you specified and pause the game.\n',"Some tips on making custom errors though:\n","  Always specifiy where the error is! Bagel.js will say which game it's in but, you know more than it about the error. You should specify which type they were making, the index of the problematic error and ideally how to fix it.\n","  Also, try to include information about the inputs the user provided. For example, if they used a duplicate ID, say what that id was in the error itself.\n","  Lastly, be nice to the programmer. Treat them like a user. It's helpful to know that you can just put in something you know's wrong and get a helpful mini-tutorial.\n","\nOne more thing: the arguments for the function is structured like this:\n","(asset, game, check, standardChecks, plugin, index) => {\n};\n","Where standardChecks contains functions and check is a function that checks objects.","\n\nGood luck! :P"].join("")},init:{required:!0,types:["function"],description:["Where you make the asset object. When it's ready, simply use the \"ready\" function to tell Bagel.js that the asset's loaded.","Here's an example:","(asset, ready, game, plugin, index, setFunction) => {","    let img = new Image();","    img.onload = _ => {","        ready(img);","    };",'   img.src = "foo";',"};"].join("\n")},get:{required:!0,types:["string"],description:"The name of the function. Usually the singular version of the asset type."},forcePreload:{required:!1,default:!1,types:["boolean"],description:'If this asset must be preloaded even when the loading mode is set to "dynamic". Be careful about how you use this because it can increase loading times.'},set:{required:!1,types:["function"],description:"Runs instead of the init function when the asset is set. Called with asset, ready, game and plugin. Setting this will replace the ready function in the init function with a function that will call this. Call it with the resource that init fetched and process it in set."},hrefArgs:{required:!1,default:["src"],check:e=>{e.includes("src")||e.push("src")},checkEach:!1,types:["array"],description:"The arguments for this asset type that are hrefs. These will be cached by Bagel.js service workers."}},types:["object"],description:"Contains the new asset types, the key is the name of type. (should be plural)"},sprites:{required:!1,default:{},arrayLike:!0,subcheck:{description:{required:!0,types:["string"],description:"A short explaination of what this sprite type does."},args:{required:!0,types:["object"],arrayLike:!0,subcheck:{description:{required:!0,types:["string"],description:"A brief description of what this property does."},types:{required:!0,types:["array"],description:"The different data types this property accepts. e.g string, array, object etc."},required:{required:!0,types:["boolean"],description:"If the argument is required or not. Most of the time, it should be optional."},checkEach:{required:!1,types:["boolean"],description:"If the check function should be run on each value of the array/object or just on the array/object itself."},check:{required:!1,types:["function"],description:"The check function."},subcheck:{required:!1,types:["object"],description:'The subcheck. Same as a "syntax" argument but there\'s no checks on what you put in here.'},arrayLike:{required:!1,default:!1,types:["boolean"],description:"If each item should be checked or not. Works for both objects and arrays."},default:{required:!1,types:"any",description:"The default value (only applies if required is false)"},ignoreUseless:{required:!1,types:["boolean"],description:"If useless arguments should be ignored or reported. Useful for when doing a general check and then a specific check depending on a value of an argument."}},check:(e,t,n,i,r,a)=>{if(a.ob.cloneArgs&&null==a.ob.cloneArgs[n])return"Oops, there's no matching cloneArg variant for the "+JSON.stringify(n)+' argument. Make sure "cloneArgs" exists for this sprite type. Clone arguments are a variant of the arguments for clones, each argument is an object with two items: "syntax" and "mode". The syntax is in the same format as the syntax in the normal args but anything unspecified defaults to the normal variant and mode is how the value\'s calculated. Check the syntax for cloneArgs for more info.'},checkEach:!0,description:'Same as the "syntax" argument for the check function. These checks are only run on original sprites, not clones.'},cloneArgs:{required:!0,types:["object","undefined"],arrayLike:!0,subcheck:{syntax:{required:!1,default:{},subcheck:{description:{required:!1,check:(e,t,n,i,r)=>{null==e&&(t[n]=r.prev.ob.args[r.prevName].description)},types:["string"],description:"A brief description of what this property does. You might want to change this to mention clones instead of sprites."},types:{required:!1,check:(e,t,n,i,r)=>{null==e&&(t[n]=r.prev.ob.args[r.prevName].types)},types:["array"],description:"The different data types this property accepts. e.g string, array, object etc."},required:{required:!1,check:(e,t,n,i,r)=>{null==e&&(t[n]=r.prev.ob.args[r.prevName].required)},types:["boolean"],description:"If the argument is required or not. Most of the time, it should be optional."},check:{required:!1,check:(e,t,n,i,r)=>{null==e&&(t[n]=r.prev.ob.args[r.prevName].check)},types:["function","undefined"],description:"The check function."},subcheck:{required:!1,check:(e,t,n,i,r)=>{null==e&&(t[n]=r.prev.ob.args[r.prevName].subcheck)},types:["object","undefined"],description:'The subcheck. Same as a "syntax" argument.'},default:{required:!1,check:(e,t,n,i,r)=>{null==e&&(t[n]=r.prev.ob.args[r.prevName].default)},types:"any",description:'The default value for when "ignore" mode is used and no value is found for a property.'}},types:["object"],description:'The syntax for clones of this sprite type. Any unspecified arguments will default to the values specified in the "args" argument for normal sprites.'},mode:{required:!1,default:"replace",check:e=>{if(!["replace","merge","ignore"].includes(e))return'Huh, looks like you used an invalid option for this. It can only be "replace", "merge" or "ignore".'},types:["string"],description:["The adoption method for this property. Either:",'  โข "replace" -> The value is given based on the order of preference (from high to low): the "clone" function inputs, the "clones" attribute in the parent and the parent sprite\'s properties.','  โข "merge" -> Only for objects and arrays. They are merged together, in the event of a conflict, the order of preference applies.','  โข "ignore" -> Ignores the parent\'s properties. However, properties will still be taken from the parent\'s "clones" argument and the "clone" function using the order of preference. The property will be set to the default from either the parent or the clone\'s arguments if no value is assigned.'].join("\n")}},description:'Same as the "syntax" argument for the check function. These checks are only run on clones, not original sprites. Unspecified properties will mean that the property doesn\'t exist for clones.'},listeners:{required:!1,default:{},subcheck:{steps:{required:!1,default:{},check:e=>{if("function"!=typeof e)return"Oops, steps can only be functions. You used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."},checkEach:!0,types:["object"],description:'Short functions that do a task. Can be called from any of the other functions using "Bagel.step.plugin.spriteListener(<step id>)".'},fns:{required:!1,default:{},check:e=>{if("function"!=typeof e)return"Oops, functions can only be, well... functions. You used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."},checkEach:!0,types:["object"],description:"Functions that can replace the functions in listeners. The key is the id for it. The id can be used in place of this function in listeners."},property:{required:!1,default:{},subcheck:{set:{required:!1,default:null,check:(e,t,n,i,r)=>{if("string"==typeof e){if(!r.ob.fns.hasOwnProperty(e))return"Huh, looks like you used an invalid id for a function. You used "+JSON.stringify(e)+".";t[n]=r.ob.fns[e]}},types:["function","string"],description:"A function that's run after the property is changed. Can also be the name of a function defined in SpriteJSON.listeners.fns. The arguments given are these: sprite, value, property, game, plugin, triggerSprite, step, initialTrigger and the value it was before it was set."},get:{required:!1,default:null,check:(e,t,n,i,r)=>{if("string"==typeof e){if(!r.ob.fns.hasOwnProperty(e))return"Hmm, looks like you used an invalid id for a function. You used "+JSON.stringify(e)+".";t[n]=r.ob.fns[e]}},types:["function","string"],description:"A function that's run before the value is sent back to the code that requested it. Can also be the name of a function defined in SpriteJSON.listeners.fns. The arguments given are these: sprite, value, property, game, plugin, triggerSprite and step. (initialTrigger doesn't apply to get listeners so initialTrigger isn't a provided argument)"},subListen:{required:!1,default:!1,types:["boolean"],description:"For objects and arrays. If changes to the individual items should be listened for. If set to true, the arguments provided to listeners becomes:\nThe object property, value, subProperty that was set in this object, game, plugin, sprite, triggerSprite, the step function, initialTrigger, original value before it was set and the property name (in the sprite object)."}},arrayLike:!0,types:["object"],description:'Contains the "set" and "get" listener functions.'},events:{required:!1,default:{},subcheck:{delete:{required:!1,types:["function","string"],check:(e,t,n,i,r)=>{if("string"==typeof e){if(!r.ob.fns.hasOwnProperty(e))return"Hmm, looks like you used an invalid id for a function. You used "+JSON.stringify(e)+".";t[n]=r.ob.fns[e]}},description:"Runs just before the sprite is deleted (so the sprite methods all still work)."}},types:["object"],description:'Lets you set a few functions to run on certain events for this type of sprite. Can also be the id of a function in "fns". The functions are called with the sprite object followed by the game object.'},trigger:{required:!1,default:!1,types:["boolean"],description:"If the listeners should be triggered during sprite initialisation. This can be useful in some situations."}},types:["object"],description:"Functions that can run when certain conditions are met."},check:{required:!1,default:null,types:["function"],description:"A function that does extra checks. Use return <error message> in the function to create an error. These are the arguments given: sprite, game, check and where."},init:{required:!1,default:null,types:["function"],description:"Initialises the sprite. Is a function. Can be used to define attributes. These are the arguments given: sprite, game and plugin."},tick:{required:!1,default:null,types:["function"],description:"Runs every frame the sprite exists, before the sprites scripts are run or it's rendered (use render.whileVisible or render.tick for rendering related processing though). Called with the sprite object, the game object and the plugin object."},render:{required:!1,default:{},subcheck:{init:{required:!1,types:["function"],description:'(Most of the time you\'ll want to use "onVisible" instead) A function that runs when the sprite is first created. The function is called with the sprite, the new bitmapSprite function and the game object.'},tick:{required:!1,types:["function"],description:'(Most of the time you\'ll want to use "whileVisible" instead) A function that runs every frame. Use the update function provided to update a bitmap sprite.\nCalled with the sprite, the update function, the new bitmap function, the delete function and the game object.'},onVisible:{required:!1,types:["function"],description:'A function that runs every time the sprite is made visible. Most of the time you\'ll want to use this to set up the rendering for the sprite. You can do this by calling "Bagel.internal.render.bitmapSprite.new" (also provided as the second argument). You should then store the value returned by returning it. This will store it in sprite.internal.Bagel.renderID. You also need to update the values using listeners on sprite properties. You can do this using "Bagel.internal.render.bitmapSprite.update".\nThe on visible function is called with the sprite, the new bitmapSprite function and the game object.'},onInvisible:{required:!1,types:["function"],description:"A function that runs every time the sprite is made visible. Most of the time you'll want to use this to delete the rendering for the sprite (you can return true to set sprite.internal.Bagel.renderID to null).\nThe on invisible function is called with the sprite, the delete bitmapSprite function and the game object."},whileVisible:{required:!1,types:["function"],description:"A function that runs every frame the sprite is visible. Most of the time you'll want to use this to update the bitmap sprite properties if they've changed.\nThe function is called with the sprite, the update bitmapSprite function, the new function, the delete function and the game object."}},types:["object"],description:'Contains some render related events. Most of the time you\'ll want to use "onVisible", "onInvisible" and "whileVisible" as described in their descriptions.'}},types:["object"],description:"Contains the new sprite types, the key is the name of type (should be singular)."}},types:["object"],description:"Creates new types. (assets and sprites)"},methods:{required:!1,default:{},subcheck:{bagel:{required:!1,default:{},arrayLike:!0,subcheck:{fn:{required:!1,subcheck:{args:{required:!1,check:(e,t)=>{if(!t.normal&&null==e)return"Oops, looks like you missed this argument."},types:["object"],description:'The syntax for the arguments. These is always an object, even if you set "obArg" to false.'},fn:{required:!0,types:["function"],description:"The method itself. The arguments are the arguments (an object) and the plugin."},obArg:{required:!1,check:(e,t)=>{if(!t.normal&&null==e)return"Oops, looks like you missed this argument."},types:["boolean"],description:"If the arguments should be inputted as an object or should use a normal function input. You probably only want to use the 2nd one if there aren't many arguments."},normal:{required:!1,default:!1,types:["boolean"],description:"If the method should just be a normal function. This can increase performance but obArg and args won't work anymore. You will also have to rely on Bagel.internal.current for finding out the current game, sprite, etc."}},types:["object"],description:"The method itself."},category:{required:!1,types:["object"],description:"Contains categories where the key is the name of the category and their contents have the same syntax as here. Note: These aren't checked."}},types:["object"],description:"Contains framework functions. (Bagel.<function>...) The key is the name and the value is the function."},game:{required:!1,default:{},arrayLike:!0,subcheck:{fn:{required:!1,subcheck:{args:{required:!1,check:(e,t)=>{if(!t.normal&&null==e)return"Oops, looks like you missed this argument."},types:["object"],description:'The syntax for the arguments. These is always an object, even if you set "obArg" to false.'},fn:{required:!0,types:["function"],description:"The method itself. The arguments are the arguments (an object) and the plugin."},obArg:{required:!1,check:(e,t)=>{if(!t.normal&&null==e)return"Oops, looks like you missed this argument."},types:["boolean"],description:"If the arguments should be inputted as an object or should use a normal function input. You probably only want to use the 2nd one if there aren't many arguments."},normal:{required:!1,default:!1,types:["boolean"],description:"If the method should just be a normal function. This can increase performance but obArg and args won't work anymore. You will also have to rely on Bagel.internal.current for finding out the current game, sprite, etc."}},types:["object"],description:"The method itself."},category:{required:!1,types:["object"],description:"Contains categories where the key is the name of the category and their contents have the same syntax as here. Note: These aren't checked."}},types:["object"],description:"Contains game functions. (Game.<function>...) The key is the name and the value is the function."},sprite:{required:!1,default:{},arrayLike:!0,subcheck:{fn:{required:!1,subcheck:{appliesTo:{required:!0,types:["array"],description:"The sprite types that this method is added to."},args:{required:!1,check:(e,t)=>{if(!t.normal&&null==e)return"Oops, looks like you missed this argument."},types:["object"],description:'The syntax for the arguments. These is always an object, even if you set "obArg" to false.'},fn:{required:!0,types:["function"],description:"The method itself. The arguments are the arguments (an object) and the plugin."},obArg:{required:!1,check:(e,t)=>{if(!t.normal&&null==e)return"Oops, looks like you missed this argument."},types:["boolean"],description:"If the arguments should be inputted as an object or should use a normal function input. You probably only want to use the 2nd one if there aren't many arguments."},normal:{required:!1,default:!1,types:["boolean"],description:"If the method should just be a normal function. This can increase performance but obArg and args won't work anymore. You will also have to rely on Bagel.internal.current for finding out the current game, sprite, etc."}},types:["object"],description:"The method itself."},category:{required:!1,types:["object"],description:"Contains categories where the key is the name of the category and their contents have the same syntax as here. Note: These aren't checked."},apply:{required:!1,subcheck:{to:{required:!1,default:[],check:e=>{if("string"!=typeof e)return"Erm, these can only be a string and you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."},checkEach:!0,types:["array"],description:"Which sprite types to apply it to."},from:{required:!1,check:(e,t,n,i,r)=>{if(r.ob.to&&null==e)return"Oh, looks like you forgot this argument."},types:["string"],description:"A sprite type that has the existing method that you want to apply to a new sprite type."}},types:["object"],description:"Allows a pre existing method from another plugin to also be applied to a sprite type created by this plugin. It's an array of the sprite types."}},types:["object"],description:"Contains sprite functions. (me.<function>...) The key is the name and the value is the function."}},types:["object"],description:'Contains the 3 different method types: "bagel", "game" and "sprite".'},scripts:{required:!1,default:{},subcheck:{preload:{required:!1,types:["function"],description:"The preload function. It runs before the plugin is checked or initialised making it useful for changing some values before loading."},init:{required:!1,types:["function"],description:"The init function. It runs once the plugin's been checked and mostly initialised. This function finishes it by doing stuff specific to this plugin."},main:{required:!1,types:["function"],description:'The "main" function. Runs on every frame before any other scripts run.'},steps:{required:!1,default:{},check:e=>{if("function"!=typeof e)return"Huh, looks like you used the wrong type, it should be a function and you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e)+".")},checkEach:!0,types:["object"],description:'Mini functions. They can help make your code clearer by spitting functions into the individual steps. Can use them with "Bagel.step.plugin.scripts" or the step function provided as an argument to the function.'}},types:["object"],description:'Contains the plugin\'s scripts. "preload", "init" and "main". Steps can also be used. The arguments provided are the plugin, the game and then the step function.'},listeners:{required:!1,default:{},subcheck:{prepState:{required:!1,types:["function"],description:"Runs on the first frame of a new game state. Regardless of if the game's loaded or not. Any loading triggered here will be part of a loading screen."},state:{required:!1,types:["function"],description:"The game state listener function. Triggers on the first frame with the new state from the start. Runs before init scripts and the loading screen. Only runs once the game's loaded but can also trigger a loading screen by requesting or adding an asset."}},types:["object"],description:"Contains listener functions for different things."}},types:["object"],description:"Contains most of the plugin stuff. e.g the new types it adds, methods and defaults."},vars:{required:!1,default:{},types:["object"],description:"An object you can use to store data for the sprite."},args:{required:!1,types:["object"],description:"The arguments provided when the plugin was loaded. You shouldn't change any of these values in the plugin, that's what the \"vars\" property is for."}},assets:{id:{required:!0,types:["string"],description:"The id to target the asset by."},src:{required:!0,types:["string"],description:'The src of the asset. e.g "assets/imgs/bagel.png"'}},disableArgCheck:{args:!0},bitmapSprite:{x:{required:!0,types:["number"],description:"The x position of the centre of the bitmap."},y:{required:!0,types:["number"],description:"The y position of the centre of the bitmap."},width:{required:!0,types:["number"],description:"The width of the bitmap. Negative widths flip the image horizontally."},height:{required:!0,types:["number"],description:"The height of the bitmap. Negative heights flip the image vertically."},image:{required:!0,types:["string"],description:'The id of the texture to use. This isn\'t exclusive to the "img" asset type (other plugins can also create new textures) but you\'ll usually use textures defined that way. In the case of the "img" asset type, when loaded, a new texture will be created with the id specified in the image.'},rotation:{required:!1,default:90,types:["number"],description:"The rotation of the bitmap in degrees."},alpha:{required:!1,default:1,check:(e,t)=>{e>1?t.alpha=1:e<0&&(t.alpha=0)},types:["number"],description:"The alpha for the bitmap sprite. 1 is fully visible, 0 is completely transparent."},crop:{required:!1,subcheck:{x:{required:!0,types:["number"],description:"The x coordinate to start using the image data. Anything before it won't be used."},y:{required:!0,types:["number"],description:"The y coordinate to start using the image data. Anything before it won't be used."},width:{required:!0,types:["number"],description:"The number of horizontal pixels to use from the image. (from the x coordinate). Anything after isn't used."},height:{required:!0,types:["number"],description:"The number of vertical pixels to use from the image. (from the y coordinate). Anything after isn't used."}},check:(e,t,n,i)=>{let r=Bagel.internal.render.texture.get(t.image,i);e.width+e.x>r.width&&(e.width=r.width-e.x),e.height+e.y>r.height&&(e.height=r.height-e.y),0==e.x&&0==e.y&&e.width==r.width&&e.height==r.height&&delete t.crop},types:["object"],description:"How the texture the bitmapSprite uses should be cropped. Won't affect the original texture and is affected by rotation. Source pixels are used instead of game or canvas pixels."},tint:{required:!1,types:["string"],description:"The HTML colour the sprite should be tinted with. If the opacity is 255, all opaque pixels will be fully replaced with the colour and if it's 0, none will be effected."}}},th:e=>e+1+(e>8&&e<20?"th":["st","nd","rd","th","th","th","th","th","th"][parseInt(e.toString()[e.toString().length-1])]),an:e=>["a","e","i","o","u"].includes(e[0].toLowerCase())?"an "+e:"a "+e,list:(e,t,n)=>{let i="";for(let n in e){let r=e[n];i+=Bagel.internal.an(r),n==e.length-2?i+=" "+t+" ":n!=e.length-1&&(i+=", ")}return i},getTypeOf:e=>Array.isArray(e)?"array":"number"==typeof e&&isNaN(e)?"NaN":null==e?"undefined":typeof e,deepClone:(e,t)=>{if("object"!=typeof e||null==e||t&&e.internal&&e.internal.dontClone)return e;let n;n=Array.isArray(e)?[]:{};let i=Object.keys(e),r=0;for(;r<i.length;)null!=e[i[r]]&&"object"==typeof e[i[r]]?n[i[r]]=Bagel.internal.deepClone(e[i[r]],!0):n[i[r]]=e[i[r]],r++;return n},compressNumbers:(e,t,n)=>{let i=e[0].length;if(!t){t=new Array(i).fill(1/0),n=new Array(i).fill(-1/0);for(let i in e)for(let r in e[i])e[i][r]>n[r]&&(n[r]=e[i][r]),e[i][r]<t[r]&&(t[r]=e[i][r])}let r=1,a=0;for(;a<i;)t[a]==n[a]&&(0==t[a]?n[a]++:t[a]--),r*=n[a]-t[a]+1,a++;let s,o,l,d,u,g=r,h=1,c=0;for(;++c!=e.length&&g!=Math.pow(128,h);)if((g*=r)>Math.pow(128,h)){if(4==h)break;h++}for(characters="",a=0;a<e.length;)for(s=0;s<c;){for(s%(c/h)==0&&(d=0,u=1),o=0;o<i;)d+=(e[a][o]-t[o])*u,u*=n[o]-t[o]+1,o++;if(a++,0!=++s&&s%(c/h)==0||a==e.length){for(l=0;l<h;)g=Math.pow(128,h-l-1),characters+=String.fromCharCode(Math.floor(d/g)),d%=g,l++;if(a==e.length)break}}return[characters,t,n,e.length]},decompressNumbers:(e,t,n,i)=>{let r=t.length,a=1,s=0;for(;s<r;)a*=n[s]-t[s]+1,s++;let o=a,l=1,d=0;for(;++d!=i&&o!=Math.pow(128,l);)if((o*=a)>Math.pow(128,l)){if(4==l)break;l++}let u=[1],g=1;for(s=0;s<r*d;)g*=n[s%n.length]-t[s%t.length]+1,u.push(g),s++;u.pop(),u.reverse();let h,c,p,f=[];for(s=0;s<e.length;){for(g=0,h=0;h<l;)g+=e.charCodeAt(s)*Math.pow(128,l-h-1),h++,s++;for(c=0;c<u.length;)(p=r-c%r-1)==r-1&&f.push([]),f[f.length-1].push(Math.floor(g/u[c])+t[p]),g%=u[c],c++}return f.reverse(),f.splice(i,f.length-i),f},findCloneID:(e,t)=>{let n=0;for(;;){let i=e.id+"#"+n;if(null==t.internal.idIndex[i])return i;n++}},findSpriteIndex:e=>{for(let t in e.game.sprites)if(null==e.game.sprites[t])return parseInt(t);return e.game.sprites.length},oops:e=>{if(null==e)throw"Critical Bagel.js error, please look at the error above for more info. ^-^";throw e.paused=!0,e.error=!0,"Critical Bagel.js error in the game "+JSON.stringify(e.id)+", look at the error for some help. ^-^"},current:{sprite:null,game:null,asset:null,assetType:null,assetTypeName:null,i:null,where:null,plugin:null,pluginProxy:!1,mainLoop:!1},saveCurrent:e=>{let t=Bagel.internal,n=t.current;t.currentStack.push({...n})},loadCurrent:e=>{let t=Bagel.internal;t.current=t.currentStack.pop()},resetCurrent:e=>{Bagel.internal.current={sprite:null,game:null,asset:null,assetType:null,assetTypeName:null,i:null,where:null,plugin:null,pluginProxy:!1,mainLoop:!1},Bagel.internal.currentStack=[]},currentStack:[],getActingPluginId:e=>{let t,n;e&&(n=(t=Bagel.internal.current).pluginProxy,t.pluginProxy=!0);let i=Bagel.internal.getActingPluginIdHelper();return e&&(t.pluginProxy=n),i},getActingPluginIdHelper:e=>{let t=Bagel.internal.currentStack,n=Bagel.internal.current;if(null==n.plugin)return null;let i=1;for(;n.pluginProxy;){if(null==(n=t[t.length-i])||null==n.plugin)return null;i++}return n.plugin.info.id},render:{bitmapSprite:{new:(e,t,n=!0)=>{"object"!=Bagel.internal.getTypeOf(t)&&(t?console.error("Huh, looks like you didn't specify the game properly (it's the 2nd argument). It's supposed to be an object but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(t))+"."):console.error("Hmm, looks like you forgot to specify the game object. (2nd argument)"),Bagel.internal.oops(Bagel.internal.current.game)),n&&(e=Bagel.check({ob:e,where:"the function Bagel.internal.render.new",syntax:Bagel.internal.checks.bitmapSprite,game:t})),e.alpha=Math.max(Math.min(e.alpha,1),0);let i=t.internal.renderer;t.config.isLoadingScreen&&(e.image=".Internal.loadingScreen."+e.image),null==t.internal.renderer.textures[e.image]&&(console.error("Oh no! Bagel.js couldn't find the texture "+JSON.stringify(e.image)+' for your bitmap sprite. Make sure your "image" argument (part of the data argument) is correct.'),Bagel.internal.oops(t));let r=i.bitmapIndexes.indexOf(null);return-1==r&&(r=i.bitmapIndexes.length),i.bitmapSpriteData[r]=e,i.bitmapsUsingTextures[e.image].push(r),i.bitmapCount++,"webgl"==i.type?(i.bitmapIndexes[r]=!0,i.queue.bitmap.new.push([e,r]),i.queueLengths.add++,t.config.isLoadingScreen&&(i.loadingScreenBitmaps[r]=!0),r):(i.bitmapIndexes[r]=i.layers.length,i.layers.push(r),i.scaledBitmaps[r]=Bagel.internal.subFunctions.tick.render.canvas.scaleData(e,i),e.tint&&Bagel.internal.render.bitmapSprite.internal.canvasTint(i,e.image,e.tint),r)},delete:(e,t)=>{if("object"!=Bagel.internal.getTypeOf(t)&&(t?console.error("Hmm, looks like you didn't specify the game properly (it's the 2nd argument). It's supposed to be an object but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(t))+"."):console.error(":/ looks like you forgot to specify the game object. (2nd argument)"),Bagel.internal.oops(Bagel.internal.current.game)),null==e)return!1;e=parseInt(e);let n=t.internal.renderer;if(t.config.isLoadingScreen&&(n.loadingScreenBitmaps[e]=!1),null==n.bitmapSpriteData[e])console.error("Huh, Bagel.js couldn't find the bitmap sprite with the id "+JSON.stringify(e)+". You might have already deleted it."),Bagel.internal.oops(t);else{if("webgl"==n.type)if("boolean"==typeof n.bitmapIndexes[e]){let t=n.queue.bitmap.new;t[t.findIndex(t=>t&&t[1]==e)]=null,n.queueLengths.add--}else n.queue.bitmap.delete[n.bitmapIndexes[e]]=!0,n.queueLengths.delete++;else{let t=n.scaledBitmaps[e];n.scaledBitmaps[e]=null,n.layers.splice(n.bitmapIndexes[e],1);let i=n.bitmapIndexes[e];for(let e in n.bitmapIndexes)n.bitmapIndexes[e]>i&&n.bitmapIndexes[e]--;t.tint&&Bagel.internal.render.bitmapSprite.internal.reduceCanvasTint(n,t.image,t.tint)}n.bitmapIndexes[e]=null,n.bitmapCount--;let t=n.bitmapSpriteData[e].image,i=n.bitmapsUsingTextures[t],r=i.indexOf(e);-1!=r&&(n.bitmapsUsingTextures[t]=i.filter((e,t)=>t!=r)),n.queue.bitmap.layer=n.queue.bitmap.layer.filter(t=>t[0]!=e),n.bitmapSpriteData[e]=null}return!0},update:(e,t,n,i=!0,r)=>{if(null==e)return Bagel.internal.render.bitmapSprite.new(t,n,i);"object"!=Bagel.internal.getTypeOf(n)&&(n?console.error("Hmm, looks like you didn't specify the game properly (it's the 2nd argument). It's supposed to be an object but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(n))+"."):console.error(":/ looks like you forgot to specify the game object. (2nd argument)"),Bagel.internal.oops(Bagel.internal.current.game)),i&&(t=Bagel.check({ob:t,where:"the function Bagel.internal.render.update",syntax:Bagel.internal.checks.bitmapSprite,game:n}));let a=n.internal.renderer;if(n.config.isLoadingScreen&&(a.loadingScreenBitmaps[e]=!0,r||(t.image=".Internal.loadingScreen."+t.image)),null==n.internal.renderer.textures[t.image]&&(console.error("Oh no! Bagel.js couldn't find the texture "+JSON.stringify(t.image)+' for your bitmap sprite. Make sure your "image" argument (part of the data argument) is correct.'),Bagel.internal.oops(n)),null==a.bitmapSpriteData[e])console.error("Hmm, Bagel.js couldn't find the bitmap sprite with the id "+JSON.stringify(e)+"."),Bagel.internal.oops(n);else{if(a.bitmapSpriteData[e].image!=t.image){let n=a.bitmapsUsingTextures[a.bitmapSpriteData[e].image],i=n.indexOf(e);n=n.filter((e,t)=>t!=i),a.bitmapsUsingTextures[t.image].push(e)}if(a.bitmapSpriteData[e]=t,"webgl"==a.type)if(!0===a.bitmapIndexes[e]){a.queue.bitmap.new.find(t=>null!=t&&t[1]==e)[0]=t}else{let n=a.vertices,i=a.textureCoordinates,r=12*a.bitmapIndexes[e],s=Math.abs(t.width/2),o=Math.abs(t.height/2),l=t.x-s,d=t.y-o,u=t.x+s,g=t.y+o;n.set([l,d,u,d,l,g,l,g,u,d,u,g],r);let h=Bagel.internal.subFunctions.tick.render.webgl;h.rotateVertices(n,r,t.rotation,t.x,t.y),h.clipVertices(n,r,a);let c=a.textures[t.image],p=c[1],f=t.alpha,m=c[2],y=c[4];-1==Math.sign(t.width)&&(m=c[4],y=c[2]);let b=c[3],w=c[5];-1==Math.sign(t.height)&&(b=c[5],w=c[3]),i.set([m,b,p,f,y,b,p,f,m,w,p,f,m,w,p,f,y,b,p,f,y,w,p,f],2*r),a.verticesUpdated=!0}else{let n=a.scaledBitmaps[e];(t.tint!=n.tint||n.tint&&t.image!=n.image)&&(n.tint&&Bagel.internal.render.bitmapSprite.internal.reduceCanvasTint(a,n.image,n.tint),t.tint&&Bagel.internal.render.bitmapSprite.internal.canvasTint(a,t.image,t.tint)),a.scaledBitmaps[e]=Bagel.internal.subFunctions.tick.render.canvas.scaleData(t,a)}}},bringToFront:(e,t)=>{Bagel.internal.render.bitmapSprite.internal.queueRenderOrder(0,e,t)},bringForwards:(e,t)=>{Bagel.internal.render.bitmapSprite.internal.queueRenderOrder(1,e,t)},sendToBack:(e,t)=>{Bagel.internal.render.bitmapSprite.internal.queueRenderOrder(2,e,t)},sendBackwards:(e,t)=>{Bagel.internal.render.bitmapSprite.internal.queueRenderOrder(3,e,t)},internal:{queueRenderOrder:(e,t,n)=>{"object"!=Bagel.internal.getTypeOf(n)&&(n?console.error("Huh, looks like you didn't specify the game properly (it's the 2nd argument). It's supposed to be an object but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(n))+"."):console.error("Hmm, looks like you forgot to specify the game object. (2nd argument)"),Bagel.internal.oops(Bagel.internal.current.game));let i=n.internal.renderer;if(null==i.bitmapSpriteData[t])console.error("Err, Bagel.js couldn't find the bitmap sprite with the id "+JSON.stringify(t)+". You might have deleted it."),Bagel.internal.oops(n);else{i.queue.bitmap.layer.push([t,e])}},reduceCanvasTint:(e,t,n)=>{e.tintedTextureCounts[t][n]--,0==e.tintedTextureCounts[t][n]&&delete e.tintedTextures[t][n]},canvasTint:(e,t,n,i)=>{if(!i){let i=e.tintedTextureCounts[t];null==i[n]?i[n]=1:i[n]++}let r,a,s=Bagel.internal.render.texture.get(t,game);e.tintedTextures[t][n]?(r=e.tintedTextures[t][n][0],a=e.tintedTextures[t][n][1],r.width=s.width,r.height=s.height,a.imageSmoothingEnabled=!1,a.globalCompositeOperation="source-over"):((r=document.createElement("canvas")).width=s.width,r.height=s.height,(a=r.getContext("2d")).imageSmoothingEnabled=!1),a.fillStyle=n,a.fillRect(0,0,r.width,r.height),a.globalCompositeOperation="destination-atop",a.drawImage(s,0,0),e.tintedTextures[t][n]=[r,a]}}},texture:{new:(e,t,n,i,r,a,s)=>{if("object"!=Bagel.internal.getTypeOf(n)&&(n?console.error("Hmm, looks like you didn't specify the game properly (it's the 3rd argument). It's supposed to be an object but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(n))+"."):console.error("Oops, looks like you forgot to specify the game object. (3rd argument)"),Bagel.internal.oops(Bagel.internal.current.game)),"object"!=Bagel.internal.getTypeOf(t)&&(console.error("Oh no! You tried to use "+Bagel.internal.an(Bagel.internal.getTypeOf(t))+" for the texture argument (the 2nd). It's supposed to be a canvas, image, svg or video."),Bagel.internal.oops(n)),"string"!=typeof e&&(console.error("Huh, looks like you tried to use "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+" for the id argument (the first). It should be a string."),Bagel.internal.oops(n)),("number"!=typeof t.width||t.width<=0)&&(console.error("Hmm, the texture.width property is invalid. It needs be a number greater than 0. Value: "+t.width+"."),Bagel.internal.oops(n)),("number"!=typeof t.height||t.height<=0)&&(console.error("Huh, the texture.height property is invalid. It needs be a number greater than 0. Value: "+t.height+"."),Bagel.internal.oops(n)),!Bagel.internal.games[n.id])return;let o=n.internal.renderer;n.config.isLoadingScreen&&(s||(e=".Internal.loadingScreen."+e),o.loadingScreenTextures[e]=!0);let l=o.textures;!i&&l[e]&&(console.error('Hmm, you tried to overwrite a texture without setting the "overwrite" argument (the 4th) to true. If this was deliberate, try setting it to true. Otherwise you can use the "check" function which returns true if a texture with that id already exists.'),Bagel.internal.oops(n));let d=Bagel.internal.render.texture.internal;l[e]?r=l[e][13]:null==r&&(r="auto");let u=a;if(null==u)if(l[e])u=l[e][12];else if("auto"==r)o.textureSlotsUsed/o.maxTextureSlots<=.8&&(u=!0);else if("animated"==r&&(u=!0,o.textureSlotsUsed==o.maxTextureSlots)){let t=!1;for(let e in l)if(l[e][12]||"animated"!=l[e][13]){let i=l[e][15];render.delete(e,n,!1,!1,!0),render.new(e,i,n,!1,r,!1,!0),t=!0;break}t||(u=!1,o.animatedIntoCombined[e]=!0,o.displayedCombinedWarning||(console.warn('There\'s no empty texture slots left. In order to try and keep the game running, Bagel.js is using a combined texture for this animated texture. This will likely have a significant performance penalty depending on the size. If you\'re using a lot of animated textures, the "canvas" renderer may be faster (Game.config.display.renderer).\nFuture animated textures going into combined textures won\'t be logged but will be recorded and can be displayed using: "Game.debug.textures.listAnimatedIntoCombined()".'),o.displayedCombinedWarning=!0))}if("webgl"==o.type){o.gl;let i=Math.ceil(t.width),a=Math.ceil(t.height),s=o.maxTextureSize,g=!1;if(i>4096||a>4096){g=!0,u=!0;let n=i/a;i>a?(i=s,a=Math.ceil(i/n)):(a=s,i=Math.ceil(a*n));let r=document.createElement("canvas");r.width=i,r.height=a,r.getContext("2d").drawImage(t,0,0,i,a),t=r,o.downscaled[e]?o.downscaled[e]++:o.downscaled[e]=1,o.displayedDownscaleWarning||(console.warn("FYI, the texture "+JSON.stringify(e)+" just got downscaled to "+i+"x"+a+' to keep it within the WebGL dimension limit for this device, affecting performance.\nIf you want this behaviour without the warning, cap the texture width and height before running this method using "Bagel.device.webgl.textureSizeLimit" to find the maximum width/height (it\'s the same for both).\nIf it has to be the full resolution, you can either set a minimum WebGL resolution limit in "Game.config.display.webgl.minimumLimits.textureSize" (keep in mind that almost no machines support textures more than 16384 pixels wide due to a texture that size taking up around 4GB of VRAM. However, most new desktops and laptops do support 16K textures so this can be your minimum if you\'re willing to exclude or accept using a canvas renderer for mostly phones and tablets.). Or you can set "Game.config.display.renderer" to "canvas" to get lower performance but have no texture limits (besides RAM and VRAM like WebGL).\n\nFuture downscales won\'t be reported for this game. But you can view the list using "Game.debug.textures.listDownscaled()".'),o.displayedDownscaleWarning=!0)}if(l[e]){let s=o.textureSlots[l[e][1]];s.canvas;if(l[e][10]!=i||l[e][11]!=a||l[e][12]!=u){let i=l[e][14],a=o.bitmapsUsingTextures[e],s=Bagel.internal.render.texture;s.delete(e,n,!1,!0,!0),s.new(e,t,n,!1,r,u,!0),l[e][14]=i,l[e][16]=!0,o.bitmapsUsingTextures[e]=a,d.regenerateBitmapCoords(e,o,n)}else{if(s[0]&&(d.initCombined(l[e][1],o,u),s=o.textureSlots[l[e][1]]),u)s.canvas=t;else{let i=d.initTexture(s,o,l[e][1],n);if(!i)return;d.drawImage(i,null,s,o,l[e][8],l[e][9],l[e][10],l[e][11]),d.drawImage(i,t,s,o,l[e][8],l[e][9],l[e][10],l[e][11])}Bagel.internal.render.texture.internal.queueMapUpdate(n,o,l[e][1])}l[e][15]=t,l[e][14]++,l[e][16]=!0,l[e][17]=0}else{o.bitmapsUsingTextures[e]=[];let s=0;for(;s<o.maxTextureSlots;){o.textureSlots[s][0]&&d.initCombined(s,o,u);let g=o.textureSlots[s];if(u&&!g.singleTexture&&0!=g.textureCount){s++;continue}let h,c,p=g.canvas,f=g.lines,m=!1,y=0,b=0,w=0,x=0;if(u)m=!0;else for(y in f){for(b in f[y]){let e=f[y][b];if(i+1<=e[2]){let t=0,n=y,i=e[1];w=e[0],x=e[1];let r=!1;for(;t<a+1;){i++,n++,r=!1;for(let t in f[n]){let a=f[n][t];if(a[1]==i&&a[0]<=e[0]){r=!0;break}}if(!r)break;t++}if(r){m=!0;break}}}if(m)break}if(p&&(h=p.width,c=p.height),m){if(u)g.canvas=t,h=t.width,c=t.height;else{let e=d.initTexture(g,o,s,n);if(!e)return;d.drawImage(e,t,g,o,w,x,i,a);let r=[],l=!1,u=f.slice(0,y);for(;y<f.length;){for(b in r.push([]),f[y]){let e=f[y][b];if(0==b&&(x>e[1]+1||x+a<e[1])){l=!0;break}if(w>e[0]+e[2]||w+i<e[0]){r[r.length-1].push(e);continue}let t=!1;if(e[0]<w){let n=w-e[0]-1;0!=n&&(r[r.length-1].push([e[0]+1,e[1],n-1]),t=!0)}if(e[0]+e[2]>w+i){let n=e[2]-(w+i-e[0])-1;0!=n&&(r[r.length-1].push([w+i+1,e[1],n]),t=!0)}t&&r[r.length-1].sort((e,t)=>e[0]-t[0])}if(0==r[r.length-1].length&&r.pop(),l)break;y++}let h=f.slice(y,f.length);g.lines=[...u,...r,...h]}return g.textureCount++,Bagel.internal.render.texture.internal.queueMapUpdate(n,o,s),void(l[e]=[g.webgltexture,s,w/h,x/c,(w+i)/h,(x+a)/c,i/h,a/c,w,x,i,a,u,r,0,t,!1,0])}s++}if(s==o.maxTextureSlots)return void(n.error||(console.error('Huh, that wasn\'t supposed to happen. Bagel.js ran out of textures. Try and reduce the number your\'e using (tip: canvas sprites have a separate texture for every clone by default) or use lower resolution textures. If you can\'t do either, you can try using the "canvas" renderer instead.\nYou can see the texture utilisation using "Game.debug.textures.showCombined(<combined texture index>)".'),Bagel.internal.oops(n)))}}else{if(l[e])for(let t in o.tintedTextures[e])Bagel.internal.render.bitmapSprite.internal.canvasTint(o,e,t,!0);else o.bitmapsUsingTextures[e]=[],o.tintedTextures[e]={},o.tintedTextureCounts[e]=0;l[e]=t}},update:(e,t,n)=>Bagel.internal.render.texture.new(e,t,n,!0),delete:(e,t,n=!0,i,r)=>{if("object"!=Bagel.internal.getTypeOf(t)&&(t?console.error("Oops, looks like you didn't specify the game properly (it's the 2nd argument). It's supposed to be an object but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(t))+"."):console.error("Hmm, looks like you forgot to specify the game object. (2nd argument)"),Bagel.internal.oops(Bagel.internal.current.game)),"string"!=typeof e&&(console.error("Oops, looks like you tried to use "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+" for the id argument (the first). It should be a string."),Bagel.internal.oops(t)),!Bagel.internal.games[t.id])return;let a=t.internal.renderer;t.config.isLoadingScreen&&(r||(e=".Internal.loadingScreen."+e),delete a.loadingScreenTextures[e]);let s=a.textures[e];if(s){if("webgl"==a.type){let e=a.textureSlots[s[1]],n=(e.canvas,e.ctx,Bagel.internal.render.texture.internal);if(e.textureCount--,0==e.textureCount)n.deactivateCombined(s[1],a,i);else{e[0]&&(n.initCombined(s[1],a,!1),e=a.textureSlots[s[1]]),n.drawImage(n.initTexture(e,a,s[1],t),null,e,a,s[8],s[9],s[10],s[11]);let i=[],r=0,o=Object.keys(e.lines);for(;r<o.length;){let t=e.lines[o[r]],n=t[0][1];if(n==s[9])break;if(n>s[9])break;i.push(t),r++}let l=0;for(;r<o.length;){let t=o[r];if(l>s[11])break;let n=s[9]+l;i.push([]);let a=i[i.length-1];if(e.lines[t][0][1]!=n){a.push([s[8],n,s[10]+1]),l++,r++;continue}let d=!1;for(let i in e.lines[t]){let r=e.lines[t][i];if(d||r[1]>=s[9]&&r[1]<=s[9]+s[11]&&r[0]>s[8]+s[10]&&(a.push([s[8],n,s[10]+1]),d=!0),a.push(r),1!=a.length){let e=a[a.length-2];if(e[0]+e[2]==r[0])e[2]+=r[2],a.pop();else if(a.length>2){let t=a[a.length-3];t[0]+t[2]==e[0]&&(t[2]+=e[2],a.splice(a.length-2,1))}}}l++,r++}for(;r<o.length;)i.push(e.lines[o[r]]),r++;e.lines=i}Bagel.internal.render.texture.internal.queueMapUpdate(t,a,s[1])}else delete a.tintedTextures[e],delete a.tintedTextureCounts[e];if(n)for(let n in a.bitmapsUsingTextures[e]){let i=a.bitmapsUsingTextures[e][n];null!=i&&Bagel.internal.render.bitmapSprite.update(i,{...a.bitmapSpriteData[i],image:".Internal.missing"},t,!1,!0)}delete a.textures[e],delete a.bitmapsUsingTextures[e]}else console.error("Huh, looks like that texture doesn't exist. You tried to delete a texture with the id "+JSON.stringify(e)+"."),Bagel.internal.oops(t)},get:(e,t)=>{"object"!=Bagel.internal.getTypeOf(t)&&(t?console.error("Hmm, looks like you didn't specify the game properly (it's the 2nd argument). It's supposed to be an object but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(t))+"."):console.error("Huh, looks like you forgot to specify the game object. (2nd argument)"),Bagel.internal.oops(Bagel.internal.current.game)),"string"!=typeof e&&(console.error(":/ looks like you tried to use "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+" for the id argument (the first). It should be a string."),Bagel.internal.oops(t)),t.config.isLoadingScreen&&(e=".Internal.loadingScreen."+e);let n=t.internal.renderer,i=n.textures[e];return!!i&&("webgl"==n.type?{width:i[10],height:i[11],internal:i}:i)},internal:{queueMapUpdate:(e,t,n)=>{t.queue.texturemapsUpdated[n]=!0},initTexture:(e,t,n,i)=>{let r=Bagel.internal.render.texture.internal;if(e.gl)return e.gl;let a={powerPreference:"high-performance",depth:!1,antialias:!1,preserveDrawingBuffer:!0};if(2==t.glTextureContexts){deactivateID=0;for(let e in t.activeGLTextureContexts){let n=t.activeGLTextureContexts[e];if(t.textureSlots[n].singleTexture){deactivateID=e;break}}Bagel.internal.render.texture.internal.deactivateCombined(t.activeGLTextureContexts[deactivateID],t,!1,!0)}else t.glTextureContexts++;let s=e.canvas.getContext("webgl",a)||e.canvas.getContext("experimental-webgl",a);if(null==s||s.isContextLost())return console.error("Hmm, not sure why this happened but Bagel.js couldn't get a webgl context for a combined texture."),Bagel.internal.oops(i),!1;e.gl=s;let o=Bagel.internal.subFunctions.tick.render.webgl.compileShader,l=o(s.VERTEX_SHADER,"\n                            attribute vec2 a_vertices;\n                            attribute vec2 a_textcoord;\n\n                            uniform vec2 u_resolution;\n\n                            varying vec2 v_texcoord;\n\n                            void main () {\n                                v_texcoord = a_textcoord;\n                                gl_Position = vec4(\n                                    (((a_vertices / u_resolution) * 2.0) - 1.0) * vec2(1, -1),\n                                    0,\n                                    1\n                                );\n                            }\n                        ",s,i),d=o(s.FRAGMENT_SHADER,"\n                            precision mediump float;\n                            uniform sampler2D u_image;\n\n                            varying vec2 v_texcoord;\n\n                            void main () {\n                                gl_FragColor = texture2D(u_image, v_texcoord);\n                            }\n                        ",s,i),u=s.createProgram();s.attachShader(u,l),s.attachShader(u,d),s.linkProgram(u),s.getProgramParameter(u,s.LINK_STATUS)||(console.error("Err... a Bagel.js shader program failed to link. That wasn't supposed to happen."),console.log(s.getProgramInfoLog(u)),s.deleteProgram(u),Bagel.internal.oops(i)),s.useProgram(u),s.blendFunc(s.ONE,s.ZERO),s.enable(s.BLEND),s.uniform2f(s.getUniformLocation(u,"u_resolution"),e.canvas.width,e.canvas.height);let g=s.getAttribLocation(u,"a_textcoord");s.enableVertexAttribArray(g),e.buffers.images=s.createBuffer(),s.bindBuffer(s.ARRAY_BUFFER,e.buffers.images),s.vertexAttribPointer(g,2,s.FLOAT,!1,0,0),s.bufferData(s.ARRAY_BUFFER,new Float32Array([0,1,1,1,0,0,1,1,1,0,0,0]),s.STATIC_DRAW);let h=s.getAttribLocation(u,"a_vertices");s.enableVertexAttribArray(h),e.buffers.vertices=s.createBuffer(),s.bindBuffer(s.ARRAY_BUFFER,e.buffers.vertices),s.vertexAttribPointer(h,2,s.FLOAT,!1,0,0),s.bufferData(s.ARRAY_BUFFER,new Float32Array,s.STREAM_DRAW);let c=t.blankTexture,p=s.createTexture();return s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,p),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.NEAREST),s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,c),s.viewport(0,0,e.canvas.width,e.canvas.height),t.activeGLTextureContexts.push(n),e.previousTexture&&(r.drawImage(s,e.previousTexture,e,t,0,0,e.canvas.width,e.canvas.height),delete e.previousTexture),s},initCombined:(e,t,n)=>{let i,r,a,s=t.textureSlots[e],o={},l={};s[2]?(i=s[3],r=s[2],o=s[4],l=s[5]):n||(i=document.createElement("canvas"),s[3]&&(a=s[3])),n||(i.width=4096,i.height=4096);let d,u=0;if(null==s[2]&&s[4])n=s[4].singleTexture,d=s[4].lines,u=s[4].textureCount;else if(d=[],!n){let e=0;for(;e<i.height;){let t=[0,e,i.width];d.push([t]),e++}}t.textureSlots[e]={canvas:i,gl:r,lines:d,webgltexture:t.textureSlots[e][1],singleTexture:n||!1,textureCount:u,locations:o,buffers:l,previousTexture:a},t.textureSlotsUsed++},deactivateCombined:(e,t,n,i)=>{let r=t.textureSlots[e];if(n)t.textureSlots[e]=[!0,r.webgltexture,r.gl,r.canvas,r.locations,r.buffers];else{let n,a;if(r.gl){if(i&&0!=r.textureCount){(n=document.createElement("canvas")).width=r.canvas.width,n.height=r.canvas.height,n.getContext("2d").drawImage(r.canvas,0,0),a={lines:r.lines,singleTexture:r.singleTexture,textureCount:r.textureCount}}r.gl.getExtension("WEBGL_lose_context").loseContext(),t.activeGLTextureContexts=t.activeGLTextureContexts.filter(t=>e!=e),t.glTextureContexts--}t.textureSlots[e]=[!0,r.webgltexture,null,n,a]}t.textureSlotsUsed--},drawImage:(e,t,n,i,r,a,s,o)=>{null==t&&(t=i.blankTexture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array([r,a+o,r+s,a+o,r,a,r+s,a+o,r+s,a,r,a]),e.STREAM_DRAW),e.drawArrays(e.TRIANGLES,0,6)},regenerateBitmapCoords:(e,t,n)=>{let i=[];for(let r in t.bitmapsUsingTextures[e]){let a=t.bitmapsUsingTextures[e][r];null!=a&&(Bagel.internal.render.bitmapSprite.update(a,t.bitmapSpriteData[a],n,!1,!0),i.push(a))}t.bitmapsUsingTextures[e]=i}}}},tryStyles:(e,t,n)=>{for(let i in n)if(CSS.supports(t,n[i]))return void(e.style[t]=n[i])},inputAction:{queued:[],queue:(e,t)=>{Bagel.internal.inputAction.queued.push([e,t])},input:e=>{let t=Bagel.internal.inputAction.queued;for(let e in t)t[e][0](t[e][1]);Bagel.internal.inputAction.queued=[]}},triggerPluginListener:(e,t,n)=>{let i=t.internal.combinedPlugins.listeners[e];if(i){let e=Bagel.internal.current;Bagel.internal.saveCurrent(),e.game=t;for(let r in i){let a=i[r];e.plugin=a.plugin,a.fn(n,t,a.plugin)}Bagel.internal.loadCurrent()}},triggerSpriteListener:(e,t,n,i,r,a,s)=>{let o=i.internal.combinedPlugins.types.sprites[n.type];if(null==o.listeners.property[t])return;if(null==o.listeners.property[t][e])return;let l=o.internal.plugin,d=Bagel.internal.current;Bagel.internal.saveCurrent(),d.sprite=n,d.game=i,d.plugin=l;let u=o.listeners.property[t],g=n.internal.Bagel.properties,h=[];if(["object","array"].includes(Bagel.internal.getTypeOf(n[t]))&&u.subListen)if(a)h.push([u[e](g[t],g[t][a],a,i,l,g,n,Bagel.step.plugin.spriteListener,r,s,t),a]);else for(let a in g[t])h.push([u[e](g[t],g[t][a],a,i,l,g,n,Bagel.step.plugin.spriteListener,r,s,t),a]);else h.push([u[e](g,g[t],t,i,l,n,Bagel.step.plugin.spriteListener,r,s)]);let c=!1;for(let a in h){let s=h[a];s[0]&&(".rerun"==s[0]?(n.internal.Bagel.rerunListeners.push([e,t,r,s[1]]),n.internal.Bagel.rerunIndex[t]=!0,c=!0):(console.error(s[0]),s[1]?isNaN(s[1])?console.log("In the sprite "+JSON.stringify(n.id)+"."+t+"."+s[1]+"."):console.log("In the sprite "+JSON.stringify(n.id)+"."+t+" item "+s[1]+"."):console.log("In the sprite "+JSON.stringify(n.id)+"."+t+"."),Bagel.internal.oops(i)))}return Bagel.internal.loadCurrent(),c},processSprite:e=>{let t=e.game,n=[...e.internal.Bagel.rerunListeners];e.internal.Bagel.rerunListeners=[],e.internal.Bagel.rerunIndex={};let i=!0;for(let r in n){let a=Bagel.internal.triggerSpriteListener(n[r][0],n[r][1],e,t,n[r][2],n[r][3]);"visible"!=n[r][1]&&a&&(i=!1)}e.internal.Bagel.rendererNotInitialized&&i&&(e.internal.Bagel.rendererNotInitialized=!1,Bagel.internal.subFunctions.createSprite.initRender(e,t));let r=t.internal.combinedPlugins.types.sprites[e.type];if(r.tick){let n=r.internal.plugin;Bagel.internal.saveCurrent();let i=Bagel.internal.current;i.sprite=e,i.plugin=n,i.game=t,r.tick(e,t,n),Bagel.internal.loadCurrent()}},processSpriteRenderOutput:(e,t)=>{null!=t&&!1!==t&&(!0===t&&(t=null),e.internal.Bagel.renderID=t)},errorGameObject:{game:{assets:{imgs:[{id:"Bagel",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADEAAAAxCAYAAABznEEcAAAABmJLR0QAzAABAADUZNSSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5QQGFQwlp+ojXQAAB3BJREFUaN7FWklsHEUUfb+7up0Be4IdI+KQmCXEiBBimyUEJE4BxI0ThEPEJiHEJiE4cIAjICEBQqyKAgKxCQk4cEDiEOCAFMgCOAECgYQkhJCwxJYdZ3F3dX8O1V1dvU6PPZCRxp7qqe6uV//995ceQodf8qMrmQiwCAARgoBhCwKiMQigG76kTt5zzhc7/uEqvWi1RlL/DSD6LuY4foNA12+iUwLi6PtXsF4TEeYKBATQdbMD0/ZJE+9dzvHCLZMldYAsGgIO/VwJBATQte2BqT3573cuY8tYbNtAFg0B8/oAb6IaiJSAKxSYNfXAWHUm/fn2ZcwAQgaYGcyI3qyOIRkzx/MARjIXbq+a6PYCA0MAA+z50cnRGwwIocf86dXcERCH3ryUPU9Gi5o9EDCAmSPJRAAkBPSFTSDGuA6QSnP9/salaeWJqYT4mBpLKXHmujF93rEPrkhRy120DOjqA4hAw8/refzx6pbOrv2kglqllvjt9VGOdzHk9C5nLSKESJ2btUiy25lNjYahJ/MWyVCtyiKFIPa+NsqcoUMrINm1mXPh9KkDM+OpeV60UMsRxknRBRyhPhhgyoDkTLRnw0haQjNKYxEgZQDXFYXUyqrW6Ysu0FSCPw7/8O5Zx5EyaoksCDb+hCAEvoTrCoAYYEIIQAgbzKwvHjJggY09UedaBMCJVMkbx8nDu6NFq2sBQAjjXDIXYKzTmN+STrvWDzNnlMYWAlXU8jxZqVr6Yk5v6lzP8/XclN/EAlUkvzGtNqZpJbIOGYJhZXYlBCVoDYtY2iootMgZa7cC2KquveVeNBYuxYnDe5Q1HQFGuUW0/NawiD6y8+VhJsMHLCJIKeE6Aq18JCu/gQyw8LYx/PXWCI77QG+3g/k3b8XEu6ORLxVHdiklulxR7CNnD6n/h3blci0r8QWTCkDIDCFEilqh8X0ZtTxfYtpj7NkwgukZ4Nw7x2hi2sf+10dwdAZqTkSlbEAUQuSpNTCkxm6kcAMXJtQyLbHjxZVclO/EFqFMflRkkUBKHPfV5wvv3k5V8YcI6OkCXNdpnTSetzq5uTeuPse5V5TGi8QXIrNkeFfHR3w/wAkfWH7P9pYJ2+Ad3xIAHHhjlHvgw3WdwnuHAKyBZYZfMHBwV4ZqnDh2LJdlQDwts3kgvi9xwiesuG9HW+nzktu/pTIgYmAZ0LVA3e/kOHD4F8N7ORfeLNTIQG1hIzQitekDxzy0DcAEovwk8RFncFUqWQz/+Dknv6nIDkBse24Fx2mDlBKOI2pTqygdavcVb1Rj4VIV2TkKkESQezeDCJjxI9UqCIj8yVVsxbGBGbBtW1skSb/zqqVVaIYx/MB3c6qPB+9Q1lC7Pw4w4+S+LfD2ba5WLWNs6cUhHW3t6MQiIHYU4OZqBVPeJ/b/BDBwfN+WUlqXARHmQkJiWEwpByqjFqeles6UCsGYPrQ7ctnyexdRy0rnO3mL+L7M7YrvSxzzGJc/+H1H+kfn3jlG0zPAjOe3rBBjasVpPABY+cQtDUT5Sfpiti3QcIAtz17cEWP8+uoIn+YkC2TEPlmumMIobUWcgVoZ/W1FrbCTPmFsYByDhCP0uIxacdJomVWa50t9Md8PctRK50od9ImMcNRtPnieorpllpumxGoalQARwsY8AXz1zNwotWv9MDecWPFMeU8DKUoaRVTrWNc8spPK6uYyZ+/pH0R3/znoGzhfyV4nqGTcW+hCLAGijuUtIm7cTLm0owpId/8gegYuAYsmWDQRMrB46Sg2PT07a+x8ZSWf5rAurGbT19K5U6tOBjPQs2AwWnh0zJvUQBqC2wby/UsrIxqJ2qVuERAjizVScaQbAPP7l4DcJkIipQIglUMxY+rgDhARbCHQgMSmpy9mi4DVD/9QGj+2v3AJEwENJ6FNnVI317gwvtM3+/zJ5bluX7N/CSy3qcpJOQVy58OSUzh65DdYSLdo4sKIiHBSJnXMqod+oG3PrdCPAbq7CAQkLZ8WpW5VO6j7pq3F5alJral/DiSmFU2wN6m/L4rsthBateY50AGxIdTnhqNUT6X2SJQoc++6vd/C5tlnT17E5q40IyoRESw5hekjBzK7gkKLmOVmEKj0vp1St45Fzli7jUpbNmZLhkWPguxPYnL8d3WxisheVI+YKtJuOyjrn1ZBVZdrnq159EeK9bd7wWK1AF+pUHff4pZxxAyWoc5x7Fw9kq0QW3VRstTqvWUbVTaU09GZEdpNsD+JqX8OJOlIjYBYlrhlgahUpxyImQjGQGo9n9j4+EVMBDT7F2P6yMHaPA1kYDTbyh9/xX4yGx85a93XVPshSwykfQls7exlfa0gCCJwxUAGbv2G2nrIcu1jkX+08YxirtSKfSosqPHLANR6enoqLJKlVtxwm/WDxyqL+L5saZGkRsk4a4VFTNVqBaCt59j/tUWKnH3pXWO11td2of/pExGYqtZ+kFapuqoVv6sa0h39bUc2RemERZbfu/3/+W1H9lWU/Sa7b2vZrAKy8v4dp+ZXNmWvL55azq0s0ql+Vfz6F6w5R2hT4HCQAAAAAElFTkSuQmCC"}]},sprites:[{id:"Bagel",img:"Bagel",vars:{vel:0,rotVel:0,waitTick:0,finished:!1},scripts:{init:[{code:(e,t)=>{e.width=Math.min(t.width,t.height)/3,e.height=e.width,e.y+=e.height/2,e.angle=-90},stateToRun:"game"}],main:[{code:e=>{if(!e.vars.finished)if(60==e.vars.waitTick){let t=e.game.height/2-e.height/2-.025*e.height;e.y>t&&(e.vars.vel-=e.height/300,e.vars.rotVel-=e.height/390),e.y+=e.vars.vel,e.angle+=e.vars.rotVel,e.vars.vel*=.9,e.vars.rotVel*=.95,e.y<t&&(e.y=t,e.angle=90,e.vars.vel=0,e.vars.rotVel=0,e.vars.finished=!0)}else e.vars.waitTick++},stateToRun:"game"}]}},{id:"DiscSlot",type:"canvas",vars:{shrinkTick:0,shrinkVel:0,delete:!1,waitTick:0},scripts:{init:[{code:(e,t)=>{e.canvas;let n=e.ctx,i=t.get.sprite("Bagel").width,r=.05*i;e.width=1.05*i,e.height=e.width,n.scale(e.scaleX,e.scaleY),e.y+=e.height/2-r/2,n.fillStyle=t.config.display.backgroundColor,n.fillRect(0,0,e.width,e.height),n.strokeStyle="#6B6B6B",n.lineCap="round",n.lineWidth=r,n.beginPath(),n.moveTo(n.lineWidth/2,n.lineWidth/2),n.lineTo(e.width-n.lineWidth/2,n.lineWidth/2),n.stroke(),n.setTransform(1,0,0,1,0,0),e.updated=!0,e.updateRes=!1},stateToRun:"game"}]},render:(e,t,n,i)=>{if(e.vars.delete)return e.delete(),void(t.get.sprite("Text").vars.ready=!0);if(t.get.sprite("Bagel").vars.finished){if(30==e.vars.waitTick){if(n.scale(e.scaleX,e.scaleY),n.fillStyle=t.config.display.backgroundColor,n.fillRect(0,0,e.width,e.height),e.vars.shrinkVel+=e.width/300,e.vars.shrinkTick+=e.vars.shrinkVel,e.vars.shrinkVel*=.95,e.vars.shrinkTick+n.lineWidth/2>=e.width/2){e.vars.shrinkTick=e.width/2-n.lineWidth/2;let t=e.ctx.lineWidth;e.ctx.lineWidth*=.9,e.y+=(t-e.ctx.lineWidth)/2,e.ctx.lineWidth<1&&(e.vars.delete=!0)}return n.beginPath(),n.moveTo(n.lineWidth/2+e.vars.shrinkTick,n.lineWidth/2),n.lineTo(e.width-n.lineWidth/2-e.vars.shrinkTick,n.lineWidth/2),n.stroke(),n.setTransform(1,0,0,1,0,0),!0}e.vars.waitTick++}},fullRes:!0,width:1,height:1,mode:"static"},{id:"Text",type:"text",y:e=>e.game.height/1.5,vars:{ready:!1,alphaVel:0},text:"",scripts:{init:[{code:(e,t)=>{let n=t.vars.loading.game.internal.errorCode;e.font=Math.min(t.width,t.height)/20+"px Helvetica",0==n&&(e.text="Looks like this device doesn't meet this game's minimum requirements.",e.visible=!1)},stateToRun:"game"}],main:[{code:e=>{e.visible?(1!=e.alpha&&(e.vars.alphaVel+=.005),e.alpha+=e.vars.alphaVel,e.alpha>1&&(e.alpha=1),e.y-=40*e.vars.alphaVel,e.vars.alphaVel*=.9):e.vars.ready&&(e.visible=!0,e.alpha=0)},stateToRun:"game"}]}}]},config:{display:{resolution:"full"}},state:"game"},requestAnimationFrame:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame,debug:{add:e=>{Bagel.internal.debug.queue.push(e)},warn:e=>Bagel.internal.debug.add(["warning",e]),log:e=>Bagel.internal.debug.add(["log",e]),send:e=>{let t=Bagel.internal.debug.queue;if(0==t.length)return;let n=Bagel.internal.debug.logList,i=JSON.stringify(t);if(n.includes(i))return Bagel.internal.debug.queue=[],!1;n.push(i);for(let e in t){let n=t[e];"warning"==n[0]?console.warn(n[1]):console.log(n[1])}return Bagel.internal.debug.queue=[],!0},queue:[],logList:[]},games:{}},check:(e,t={},n,i)=>{if(e.prev||t.args||(e=Bagel.check({ob:e,where:e.where?e.where:"the check function. (Bagel.check)",syntax:{ob:{required:!0,types:["object","array"],description:"The object or array of objects to check."},where:{required:!0,types:["string"],description:"A description of what it's checking."},syntax:{required:!0,types:["object"],description:["The syntax for the object. e.g {",'    // "foo" is the argument name',"    foo: {",'        required: true, // If the "foo" argument is required or not.','        //default: "foo", // If it\'s not required, it needs a default','        types: ["string"], // The different data types to accept. e.g array, object, string, number etc.','        description: "foo" // A clear and to the point explaination of what this argument does',"    }","}"].join("\n")},game:{required:!1,skipCloning:!0,default:Bagel.internal.current.game,types:["object"],description:"The game object. Optional if this is being run in a script."}}},Bagel.internal.checks.disableArgCheck,!0)),t.missing&&t.types&&t.useless)return e.ob;e.hasOwnProperty("game")||(e.game=Bagel.internal.current.game);let r,a=Bagel.internal.debug,s=["array","string"],o=[],l=[],d=[],u=[];r=t.missing?e.ob:{...e.ob,...e.syntax};let g={};for(let n in r){if(g[n])continue;g[n]=!0;let i=e.syntax[n],r=e.ob[n];if(null==i){t.useless||o.push(n);continue}if("ignore"==i)continue;let a=!1;e.ob.hasOwnProperty(n)||(i.required?l.push(n):(i.hasOwnProperty("default")&&(i.skipCloning?e.ob[n]=i.default:e.ob[n]=Bagel.internal.deepClone(i.default),r=e.ob[n]),a=!0)),t.types||a||0==l.length&&(null==i.types&&(console.error("The syntax for "+e.where+"."+n+' is missing the "types" argument.'),console.log("In "+e.where+"."),console.log("Syntax:"),console.log(i),Bagel.internal.oops(e.game)),s.includes(Bagel.internal.getTypeOf(i.types))||(console.error("The syntax for "+e.where+"."+n+' has the wrong data type for the "types" argument. You used '+Bagel.internal.an(Bagel.internal.getTypeOf(i.types))+"."),console.log("In "+e.where+"."),console.log("Syntax:"),console.log(i),Bagel.internal.oops(e.game)),i.types.includes(Bagel.internal.getTypeOf(r))||"any"==i.types||d.push(n)),(i.subcheck||i.check)&&u.push(n)}let h=0!=l.length||0!=d.length;if(o.length>0&&(1==o.length?a.warn("Oops, looks like you used an unsupported argument"+(h?"":" in "+e.where)+": "+JSON.stringify(o[0])+". You can leave this alone if you want, but it doesn't need to be there."):a.warn("Hmm, looks like you used some unsupported arguments"+(h?"":" in "+e.where)+":\n  โข "+o.map((e,t)=>JSON.stringify(e)).join("\n  โข ")+"\n\nYou can leave these if you want, but they don't need to be there."),i&&a.log(i)),l.length>0&&(1==l.length?console.error("Hmm, looks like you forgot the "+JSON.stringify(l[0])+" argument."):console.error("Whelp, looks like you forgot some arguments:\n"+l.map(t=>"  โข "+JSON.stringify(t)+" -> "+e.syntax[t].description).join("\n")),i&&console.log(i)),d.length>0&&(1==d.length?console.error(":/ looks like you used the wrong type for the "+JSON.stringify(d[0])+" argument. You used "+Bagel.internal.an(Bagel.internal.getTypeOf(e.ob[d[0]]))+" instead of "+Bagel.internal.list(e.syntax[d[0]].types,"or",!0)+"."):console.error("Hmm, looks like you got some types wrong:\n"+d.map((t,n)=>"  โข "+JSON.stringify(t)+" -> Should be "+Bagel.internal.list(e.syntax[t].types,"or",!0)+". You used "+Bagel.internal.an(Bagel.internal.getTypeOf(e.ob[d[n]]))+".").join("\n")),i&&console.log(i)),o.length+d.length!=0&&a.warn("FYI, these are the arguments:\n"+Object.keys(e.syntax).filter(t=>"ignore"!=e.syntax[t]).map(t=>"  โข "+(e.syntax[t].required?"":"(optional) ")+JSON.stringify(t)+" -> "+e.syntax[t].description+"\n  Can "+(1==e.syntax[t].types.length?"only ":"")+"use "+Bagel.internal.list(e.syntax[t].types,"or",!0)+".").join("\n\n")),h&&(a.log("In "+e.where+"."),a.send()&&(console.log("Object:"),console.log(e.ob),i&&console.log(i)),Bagel.internal.oops(e.game)),a.send(),u.length>0)for(let t in u){let n=u[t],i=e.syntax[n];if(i.subcheck&&"object"==typeof e.ob[n]){let t=Array.isArray(e.ob[n]);if(t||i.arrayLike)for(let r in e.ob[n])Bagel.check({ob:e.ob[n][r],where:t?e.where+"."+n+" item "+r:e.where+"."+n+"."+r,syntax:i.subcheck,prev:e,prevName:r,game:e.game},{...Bagel.internal.checks.disableArgCheck,useless:i.ignoreUseless});else Bagel.check({ob:e.ob[n],where:e.where+"."+n,syntax:i.subcheck,prev:e,prevName:n,game:e.game},{...Bagel.internal.checks.disableArgCheck,useless:i.ignoreUseless})}if(i.check)if(i.checkEach){let t=e;for(let r in e.ob[n]){let a=i.check(e.ob[n][r],e.ob[n],r,n,e.game,t,e);a&&(console.error(a),isNaN(r)?console.log("In "+e.where+"."+n+"."+r+"."):console.log("In "+e.where+"."+n+" item "+r+"."),console.log("Value:"),console.log(e.ob[n][r]),Bagel.internal.oops(e.game))}}else{let t=i.check(e.ob[n],e.ob,n,e.game,e.prev,e);t&&(console.error(t),console.log("In "+e.where+"."+n+"."),console.log("Value:"),console.log(e.ob[n]),Bagel.internal.oops(e.game))}}return e.ob},get:{asset:{},sprite:(e,t,n)=>{if(null==t&&(t=Bagel.internal.current.game),null==t&&(console.error("Oops. Looks like you're trying to run this function outside of a script. Try moving it and trying again. Alternatively, you can pass the game object in as the second argument to this function to fix this issue."),Bagel.internal.oops()),null==e&&console.error("Oops, you forgot the first argument: the id. It's the id for the sprite you want to get").Bagel.internal.oops(t),"string"!=typeof e&&(console.error("Oops, the id for Bagel.get.sprite can only be a string but you used "+Bagel.internal.an(Bagel.internal.getTypeOf(e))+"."),Bagel.internal.oops(t)),null==t.internal.idIndex[e]){if(n)return!1;console.error("Hmm, Bagel.js couldn't get the sprite "+JSON.stringify(e)+" because it doesn't seem to exist. You might want to check its id and the game this is running in or on."),Bagel.internal.oops(t)}return t.game.sprites[t.internal.idIndex[e]]},game:e=>{if(null==e&&console.error("Oops, you forgot the first argument: the id. It's the id for the game you want to get.").Bagel.internal.oops(Bagel.internal.current.game),null==Bagel.internal.games[e]){if(check)return!1;console.error(":/ Bagel.js couldn't get the game "+JSON.stringify(e)+" because it doesn't seem to exist."),Bagel.internal.oops(Bagel.internal.current.game)}return Bagel.internal.games[e]}},set:{asset:{}},step:{sprite:(e,t,n)=>{let i=Bagel.internal.current;n=n||i.game,null==(t=t||i.sprite)&&(console.error("Oops, this must be run in a sprite script."),Bagel.internal.oops(n)),null==n&&(console.error("Huh, this isn't being run inside a game and you didn't specifiy a game. You can fix this either by moving it inside a script or providing the game object as the last argument."),Bagel.internal.oops());let r=t.scripts.steps[e];return null==r&&(console.error("Huh, the step "+JSON.stringify(e)+" doesn't exist in the sprite "+JSON.stringify(t.id)+"."),Bagel.internal.oops(n)),r(t,n,Bagel.step.sprite)},plugin:{scripts:e=>{let t=Bagel.internal.current,n=t.game,i=t.plugin;null==i&&(console.error("Oops, this must be run inside a plugin."),Bagel.internal.oops(n));let r=i.plugin.scripts.steps[e];return null==r&&(console.error("Huh, the step "+JSON.stringify(e)+" doesn't exist in plugin "+i.info.id+"."),Bagel.internal.oops(n)),r(i,n,Bagel.step.plugin.scripts)},spriteListener:e=>{let t=Bagel.internal.current,n=t.sprite,i=t.game,r=t.plugin;null==r&&(console.error("Oops, this must be run inside a plugin."),Bagel.internal.oops(i));let a=r.plugin.types.sprites[n.type].listeners.steps[e];return null==a&&(console.error("Huh, the step "+JSON.stringify(e)+" doesn't exist in plugin "+r.info.id+".plugin.types.sprites."+n.type+".listeners.steps. Make sure the id is correct, also remember it's case sensitive."),Bagel.internal.oops(i)),a(r,i,Bagel.step.plugin.spriteListener)}}},config:{flags:{warnOfUselessParameters:!0}},device:{browser:(e=>window.chrome?"Chrome":navigator.userAgent.includes("Firefox")?"Firefox":navigator.userAgent.includes("Safari")?"Safari":void 0)(),is:{touchscreen:null===document.ontouchstart,webGLSupported:null,webPSupported:(e=>{let t=document.createElement("canvas");t.width=1,t.height=1;t.getContext("2d");if(t.toDataURL("image/webp").includes("webp"))return!0;let n=navigator.userAgent;if(n.includes("Firefox")){return parseFloat(n.slice(n.indexOf("Firefox")+8))>=65}return!1})(),oggSupported:""!=(new Audio).canPlayType("audio/ogg;codecs=opus")},webgl:{}},events:{pwaUpdate:null},version:"1.6a"},Bagel.internal.requestAnimationFrame.call(window,Bagel.internal.tick);
